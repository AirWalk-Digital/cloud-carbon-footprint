"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddAccountRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            childNick: 'ChildNick',
            childUserId: 'ChildUserId',
            parentUserId: 'ParentUserId',
            permissionCodes: 'PermissionCodes',
            relationType: 'RelationType',
            requestId: 'RequestId',
            roleCodes: 'RoleCodes',
        };
    }
    static types() {
        return {
            childNick: 'string',
            childUserId: 'number',
            parentUserId: 'number',
            permissionCodes: { 'type': 'array', 'itemType': 'string' },
            relationType: 'string',
            requestId: 'string',
            roleCodes: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AddAccountRelationRequest = AddAccountRelationRequest;
class AddAccountRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AddAccountRelationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AddAccountRelationResponseBody = AddAccountRelationResponseBody;
class AddAccountRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddAccountRelationResponseBody,
        };
    }
}
exports.AddAccountRelationResponse = AddAccountRelationResponse;
class AllocateCostUnitResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fromUnitId: 'FromUnitId',
            fromUnitUserId: 'FromUnitUserId',
            resourceInstanceList: 'ResourceInstanceList',
            toUnitId: 'ToUnitId',
            toUnitUserId: 'ToUnitUserId',
        };
    }
    static types() {
        return {
            fromUnitId: 'number',
            fromUnitUserId: 'number',
            resourceInstanceList: { 'type': 'array', 'itemType': AllocateCostUnitResourceRequestResourceInstanceList },
            toUnitId: 'number',
            toUnitUserId: 'number',
        };
    }
}
exports.AllocateCostUnitResourceRequest = AllocateCostUnitResourceRequest;
class AllocateCostUnitResourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AllocateCostUnitResourceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AllocateCostUnitResourceResponseBody = AllocateCostUnitResourceResponseBody;
class AllocateCostUnitResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AllocateCostUnitResourceResponseBody,
        };
    }
}
exports.AllocateCostUnitResourceResponse = AllocateCostUnitResourceResponse;
class ApplyInvoiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addressId: 'AddressId',
            applyUserNick: 'ApplyUserNick',
            customerId: 'CustomerId',
            invoiceAmount: 'InvoiceAmount',
            invoiceByAmount: 'InvoiceByAmount',
            invoicingType: 'InvoicingType',
            ownerId: 'OwnerId',
            processWay: 'ProcessWay',
            selectedIds: 'SelectedIds',
            userRemark: 'UserRemark',
        };
    }
    static types() {
        return {
            addressId: 'number',
            applyUserNick: 'string',
            customerId: 'number',
            invoiceAmount: 'number',
            invoiceByAmount: 'boolean',
            invoicingType: 'number',
            ownerId: 'number',
            processWay: 'number',
            selectedIds: { 'type': 'array', 'itemType': 'number' },
            userRemark: 'string',
        };
    }
}
exports.ApplyInvoiceRequest = ApplyInvoiceRequest;
class ApplyInvoiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ApplyInvoiceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ApplyInvoiceResponseBody = ApplyInvoiceResponseBody;
class ApplyInvoiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ApplyInvoiceResponseBody,
        };
    }
}
exports.ApplyInvoiceResponse = ApplyInvoiceResponse;
class CancelOrderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            orderId: 'string',
            ownerId: 'number',
        };
    }
}
exports.CancelOrderRequest = CancelOrderRequest;
class CancelOrderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CancelOrderResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CancelOrderResponseBody = CancelOrderResponseBody;
class CancelOrderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelOrderResponseBody,
        };
    }
}
exports.CancelOrderResponse = CancelOrderResponse;
class ChangeResellerConsumeAmountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustType: 'AdjustType',
            amount: 'Amount',
            businessType: 'BusinessType',
            currency: 'Currency',
            extendMap: 'ExtendMap',
            outBizId: 'OutBizId',
            ownerId: 'OwnerId',
            source: 'Source',
        };
    }
    static types() {
        return {
            adjustType: 'string',
            amount: 'string',
            businessType: 'string',
            currency: 'string',
            extendMap: 'string',
            outBizId: 'string',
            ownerId: 'number',
            source: 'string',
        };
    }
}
exports.ChangeResellerConsumeAmountRequest = ChangeResellerConsumeAmountRequest;
class ChangeResellerConsumeAmountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ChangeResellerConsumeAmountResponseBody = ChangeResellerConsumeAmountResponseBody;
class ChangeResellerConsumeAmountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ChangeResellerConsumeAmountResponseBody,
        };
    }
}
exports.ChangeResellerConsumeAmountResponse = ChangeResellerConsumeAmountResponse;
class ConfirmRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            childUserId: 'ChildUserId',
            confirmCode: 'ConfirmCode',
            parentUserId: 'ParentUserId',
            permissionCodes: 'PermissionCodes',
            relationId: 'RelationId',
            relationType: 'RelationType',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            childUserId: 'number',
            confirmCode: 'string',
            parentUserId: 'number',
            permissionCodes: { 'type': 'array', 'itemType': 'string' },
            relationId: 'number',
            relationType: 'string',
            requestId: 'string',
        };
    }
}
exports.ConfirmRelationRequest = ConfirmRelationRequest;
class ConfirmRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ConfirmRelationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ConfirmRelationResponseBody = ConfirmRelationResponseBody;
class ConfirmRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConfirmRelationResponseBody,
        };
    }
}
exports.ConfirmRelationResponse = ConfirmRelationResponse;
class ConvertChargeTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            ownerId: 'OwnerId',
            period: 'Period',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            ownerId: 'number',
            period: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.ConvertChargeTypeRequest = ConvertChargeTypeRequest;
class ConvertChargeTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ConvertChargeTypeResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ConvertChargeTypeResponseBody = ConvertChargeTypeResponseBody;
class ConvertChargeTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConvertChargeTypeResponseBody,
        };
    }
}
exports.ConvertChargeTypeResponse = ConvertChargeTypeResponse;
class CreateAgAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountAttr: 'AccountAttr',
            cityName: 'CityName',
            enterpriseName: 'EnterpriseName',
            firstName: 'FirstName',
            lastName: 'LastName',
            loginEmail: 'LoginEmail',
            nationCode: 'NationCode',
            postcode: 'Postcode',
            provinceName: 'ProvinceName',
        };
    }
    static types() {
        return {
            accountAttr: 'string',
            cityName: 'string',
            enterpriseName: 'string',
            firstName: 'string',
            lastName: 'string',
            loginEmail: 'string',
            nationCode: 'string',
            postcode: 'string',
            provinceName: 'string',
        };
    }
}
exports.CreateAgAccountRequest = CreateAgAccountRequest;
class CreateAgAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            agRelationDto: 'AgRelationDto',
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            agRelationDto: CreateAgAccountResponseBodyAgRelationDto,
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateAgAccountResponseBody = CreateAgAccountResponseBody;
class CreateAgAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAgAccountResponseBody,
        };
    }
}
exports.CreateAgAccountResponse = CreateAgAccountResponse;
class CreateCostUnitRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unitEntityList: 'UnitEntityList',
        };
    }
    static types() {
        return {
            unitEntityList: { 'type': 'array', 'itemType': CreateCostUnitRequestUnitEntityList },
        };
    }
}
exports.CreateCostUnitRequest = CreateCostUnitRequest;
class CreateCostUnitResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateCostUnitResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateCostUnitResponseBody = CreateCostUnitResponseBody;
class CreateCostUnitResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCostUnitResponseBody,
        };
    }
}
exports.CreateCostUnitResponse = CreateCostUnitResponse;
class CreateInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            logistics: 'Logistics',
            ownerId: 'OwnerId',
            parameter: 'Parameter',
            period: 'Period',
            productCode: 'ProductCode',
            productType: 'ProductType',
            renewPeriod: 'RenewPeriod',
            renewalStatus: 'RenewalStatus',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            logistics: 'string',
            ownerId: 'number',
            parameter: { 'type': 'array', 'itemType': CreateInstanceRequestParameter },
            period: 'number',
            productCode: 'string',
            productType: 'string',
            renewPeriod: 'number',
            renewalStatus: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.CreateInstanceRequest = CreateInstanceRequest;
class CreateInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateInstanceResponseBody = CreateInstanceResponseBody;
class CreateInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateInstanceResponseBody,
        };
    }
}
exports.CreateInstanceResponse = CreateInstanceResponse;
class CreateResellerUserQuotaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'Amount',
            currency: 'Currency',
            outBizId: 'OutBizId',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            amount: 'string',
            currency: 'string',
            outBizId: 'string',
            ownerId: 'number',
        };
    }
}
exports.CreateResellerUserQuotaRequest = CreateResellerUserQuotaRequest;
class CreateResellerUserQuotaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateResellerUserQuotaResponseBody = CreateResellerUserQuotaResponseBody;
class CreateResellerUserQuotaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateResellerUserQuotaResponseBody,
        };
    }
}
exports.CreateResellerUserQuotaResponse = CreateResellerUserQuotaResponse;
class CreateResourcePackageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'Duration',
            effectiveDate: 'EffectiveDate',
            ownerId: 'OwnerId',
            packageType: 'PackageType',
            pricingCycle: 'PricingCycle',
            productCode: 'ProductCode',
            specification: 'Specification',
        };
    }
    static types() {
        return {
            duration: 'number',
            effectiveDate: 'string',
            ownerId: 'number',
            packageType: 'string',
            pricingCycle: 'string',
            productCode: 'string',
            specification: 'string',
        };
    }
}
exports.CreateResourcePackageRequest = CreateResourcePackageRequest;
class CreateResourcePackageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateResourcePackageResponseBodyData,
            message: 'string',
            orderId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateResourcePackageResponseBody = CreateResourcePackageResponseBody;
class CreateResourcePackageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateResourcePackageResponseBody,
        };
    }
}
exports.CreateResourcePackageResponse = CreateResourcePackageResponse;
class CreateSavingsPlansInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
            duration: 'Duration',
            effectiveDate: 'EffectiveDate',
            extendMap: 'ExtendMap',
            payMode: 'PayMode',
            poolValue: 'PoolValue',
            pricingCycle: 'PricingCycle',
            region: 'Region',
            specType: 'SpecType',
            specification: 'Specification',
            type: 'Type',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
            duration: 'string',
            effectiveDate: 'string',
            extendMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            payMode: 'string',
            poolValue: 'string',
            pricingCycle: 'string',
            region: 'string',
            specType: 'string',
            specification: 'string',
            type: 'string',
        };
    }
}
exports.CreateSavingsPlansInstanceRequest = CreateSavingsPlansInstanceRequest;
class CreateSavingsPlansInstanceShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
            duration: 'Duration',
            effectiveDate: 'EffectiveDate',
            extendMapShrink: 'ExtendMap',
            payMode: 'PayMode',
            poolValue: 'PoolValue',
            pricingCycle: 'PricingCycle',
            region: 'Region',
            specType: 'SpecType',
            specification: 'Specification',
            type: 'Type',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
            duration: 'string',
            effectiveDate: 'string',
            extendMapShrink: 'string',
            payMode: 'string',
            poolValue: 'string',
            pricingCycle: 'string',
            region: 'string',
            specType: 'string',
            specification: 'string',
            type: 'string',
        };
    }
}
exports.CreateSavingsPlansInstanceShrinkRequest = CreateSavingsPlansInstanceShrinkRequest;
class CreateSavingsPlansInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateSavingsPlansInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSavingsPlansInstanceResponseBody = CreateSavingsPlansInstanceResponseBody;
class CreateSavingsPlansInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSavingsPlansInstanceResponseBody,
        };
    }
}
exports.CreateSavingsPlansInstanceResponse = CreateSavingsPlansInstanceResponse;
class DeleteCostUnitRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            unitId: 'UnitId',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            unitId: 'number',
        };
    }
}
exports.DeleteCostUnitRequest = DeleteCostUnitRequest;
class DeleteCostUnitResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DeleteCostUnitResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteCostUnitResponseBody = DeleteCostUnitResponseBody;
class DeleteCostUnitResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteCostUnitResponseBody,
        };
    }
}
exports.DeleteCostUnitResponse = DeleteCostUnitResponse;
class DescribeCostBudgetsSummaryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            budgetName: 'BudgetName',
            budgetStatus: 'BudgetStatus',
            budgetType: 'BudgetType',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
        };
    }
    static types() {
        return {
            budgetName: 'string',
            budgetStatus: 'string',
            budgetType: 'string',
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.DescribeCostBudgetsSummaryRequest = DescribeCostBudgetsSummaryRequest;
class DescribeCostBudgetsSummaryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeCostBudgetsSummaryResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeCostBudgetsSummaryResponseBody = DescribeCostBudgetsSummaryResponseBody;
class DescribeCostBudgetsSummaryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCostBudgetsSummaryResponseBody,
        };
    }
}
exports.DescribeCostBudgetsSummaryResponse = DescribeCostBudgetsSummaryResponse;
class DescribeInstanceAmortizedCostByAmortizationPeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerIdList: 'BillOwnerIdList',
            billUserIdList: 'BillUserIdList',
            billingCycle: 'BillingCycle',
            consumePeriodFilter: 'ConsumePeriodFilter',
            costUnitCode: 'CostUnitCode',
            instanceIdList: 'InstanceIdList',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billOwnerIdList: { 'type': 'array', 'itemType': 'string' },
            billUserIdList: { 'type': 'array', 'itemType': 'string' },
            billingCycle: 'string',
            consumePeriodFilter: { 'type': 'array', 'itemType': 'string' },
            costUnitCode: 'string',
            instanceIdList: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
            productCode: 'string',
            productDetail: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodRequest = DescribeInstanceAmortizedCostByAmortizationPeriodRequest;
class DescribeInstanceAmortizedCostByAmortizationPeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodResponseBody = DescribeInstanceAmortizedCostByAmortizationPeriodResponseBody;
class DescribeInstanceAmortizedCostByAmortizationPeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceAmortizedCostByAmortizationPeriodResponseBody,
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodResponse = DescribeInstanceAmortizedCostByAmortizationPeriodResponse;
class DescribeInstanceAmortizedCostByAmortizationPeriodDateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationDateEnd: 'AmortizationDateEnd',
            amortizationDateStart: 'AmortizationDateStart',
            billOwnerIdList: 'BillOwnerIdList',
            billUserIdList: 'BillUserIdList',
            billingCycle: 'BillingCycle',
            costUnitCode: 'CostUnitCode',
            instanceIdList: 'InstanceIdList',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            amortizationDateEnd: 'string',
            amortizationDateStart: 'string',
            billOwnerIdList: { 'type': 'array', 'itemType': 'string' },
            billUserIdList: { 'type': 'array', 'itemType': 'string' },
            billingCycle: 'string',
            costUnitCode: 'string',
            instanceIdList: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
            productCode: 'string',
            productDetail: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodDateRequest = DescribeInstanceAmortizedCostByAmortizationPeriodDateRequest;
class DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBody = DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBody;
class DescribeInstanceAmortizedCostByAmortizationPeriodDateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBody,
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodDateResponse = DescribeInstanceAmortizedCostByAmortizationPeriodDateResponse;
class DescribeInstanceAmortizedCostByConsumePeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriodFilter: 'AmortizationPeriodFilter',
            billOwnerIdList: 'BillOwnerIdList',
            billUserIdList: 'BillUserIdList',
            billingCycle: 'BillingCycle',
            costUnitCode: 'CostUnitCode',
            instanceIdList: 'InstanceIdList',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            amortizationPeriodFilter: { 'type': 'array', 'itemType': 'string' },
            billOwnerIdList: { 'type': 'array', 'itemType': 'string' },
            billUserIdList: { 'type': 'array', 'itemType': 'string' },
            billingCycle: 'string',
            costUnitCode: 'string',
            instanceIdList: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
            productCode: 'string',
            productDetail: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeInstanceAmortizedCostByConsumePeriodRequest = DescribeInstanceAmortizedCostByConsumePeriodRequest;
class DescribeInstanceAmortizedCostByConsumePeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeInstanceAmortizedCostByConsumePeriodResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeInstanceAmortizedCostByConsumePeriodResponseBody = DescribeInstanceAmortizedCostByConsumePeriodResponseBody;
class DescribeInstanceAmortizedCostByConsumePeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceAmortizedCostByConsumePeriodResponseBody,
        };
    }
}
exports.DescribeInstanceAmortizedCostByConsumePeriodResponse = DescribeInstanceAmortizedCostByConsumePeriodResponse;
class DescribeInstanceBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            billingDate: 'BillingDate',
            granularity: 'Granularity',
            instanceID: 'InstanceID',
            isBillingItem: 'IsBillingItem',
            isHideZeroCharge: 'IsHideZeroCharge',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            billingDate: 'string',
            granularity: 'string',
            instanceID: 'string',
            isBillingItem: 'boolean',
            isHideZeroCharge: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeInstanceBillRequest = DescribeInstanceBillRequest;
class DescribeInstanceBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeInstanceBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeInstanceBillResponseBody = DescribeInstanceBillResponseBody;
class DescribeInstanceBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceBillResponseBody,
        };
    }
}
exports.DescribeInstanceBillResponse = DescribeInstanceBillResponse;
class DescribePricingModuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribePricingModuleRequest = DescribePricingModuleRequest;
class DescribePricingModuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribePricingModuleResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribePricingModuleResponseBody = DescribePricingModuleResponseBody;
class DescribePricingModuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePricingModuleResponseBody,
        };
    }
}
exports.DescribePricingModuleResponse = DescribePricingModuleResponse;
class DescribeProductAmortizedCostByAmortizationPeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerIdList: 'BillOwnerIdList',
            billUserIdList: 'BillUserIdList',
            billingCycle: 'BillingCycle',
            consumePeriodFilter: 'ConsumePeriodFilter',
            costUnitCode: 'CostUnitCode',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billOwnerIdList: { 'type': 'array', 'itemType': 'string' },
            billUserIdList: { 'type': 'array', 'itemType': 'string' },
            billingCycle: 'string',
            consumePeriodFilter: { 'type': 'array', 'itemType': 'string' },
            costUnitCode: 'string',
            maxResults: 'number',
            nextToken: 'string',
            productCode: 'string',
            productDetail: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeProductAmortizedCostByAmortizationPeriodRequest = DescribeProductAmortizedCostByAmortizationPeriodRequest;
class DescribeProductAmortizedCostByAmortizationPeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeProductAmortizedCostByAmortizationPeriodResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeProductAmortizedCostByAmortizationPeriodResponseBody = DescribeProductAmortizedCostByAmortizationPeriodResponseBody;
class DescribeProductAmortizedCostByAmortizationPeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeProductAmortizedCostByAmortizationPeriodResponseBody,
        };
    }
}
exports.DescribeProductAmortizedCostByAmortizationPeriodResponse = DescribeProductAmortizedCostByAmortizationPeriodResponse;
class DescribeProductAmortizedCostByConsumePeriodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriodFilter: 'AmortizationPeriodFilter',
            billOwnerIdList: 'BillOwnerIdList',
            billUserIdList: 'BillUserIdList',
            billingCycle: 'BillingCycle',
            costUnitCode: 'CostUnitCode',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            amortizationPeriodFilter: { 'type': 'array', 'itemType': 'string' },
            billOwnerIdList: { 'type': 'array', 'itemType': 'string' },
            billUserIdList: { 'type': 'array', 'itemType': 'string' },
            billingCycle: 'string',
            costUnitCode: 'string',
            maxResults: 'number',
            nextToken: 'string',
            productCode: 'string',
            productDetail: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeProductAmortizedCostByConsumePeriodRequest = DescribeProductAmortizedCostByConsumePeriodRequest;
class DescribeProductAmortizedCostByConsumePeriodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeProductAmortizedCostByConsumePeriodResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeProductAmortizedCostByConsumePeriodResponseBody = DescribeProductAmortizedCostByConsumePeriodResponseBody;
class DescribeProductAmortizedCostByConsumePeriodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeProductAmortizedCostByConsumePeriodResponseBody,
        };
    }
}
exports.DescribeProductAmortizedCostByConsumePeriodResponse = DescribeProductAmortizedCostByConsumePeriodResponse;
class DescribeResourceCoverageDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            periodType: 'PeriodType',
            resourceType: 'ResourceType',
            startPeriod: 'StartPeriod',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            maxResults: 'number',
            nextToken: 'string',
            periodType: 'string',
            resourceType: 'string',
            startPeriod: 'string',
        };
    }
}
exports.DescribeResourceCoverageDetailRequest = DescribeResourceCoverageDetailRequest;
class DescribeResourceCoverageDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeResourceCoverageDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeResourceCoverageDetailResponseBody = DescribeResourceCoverageDetailResponseBody;
class DescribeResourceCoverageDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourceCoverageDetailResponseBody,
        };
    }
}
exports.DescribeResourceCoverageDetailResponse = DescribeResourceCoverageDetailResponse;
class DescribeResourceCoverageTotalRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            periodType: 'PeriodType',
            resourceType: 'ResourceType',
            startPeriod: 'StartPeriod',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            periodType: 'string',
            resourceType: 'string',
            startPeriod: 'string',
        };
    }
}
exports.DescribeResourceCoverageTotalRequest = DescribeResourceCoverageTotalRequest;
class DescribeResourceCoverageTotalResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeResourceCoverageTotalResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeResourceCoverageTotalResponseBody = DescribeResourceCoverageTotalResponseBody;
class DescribeResourceCoverageTotalResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourceCoverageTotalResponseBody,
        };
    }
}
exports.DescribeResourceCoverageTotalResponse = DescribeResourceCoverageTotalResponse;
class DescribeResourcePackageProductRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productCode: 'ProductCode',
        };
    }
    static types() {
        return {
            productCode: 'string',
        };
    }
}
exports.DescribeResourcePackageProductRequest = DescribeResourcePackageProductRequest;
class DescribeResourcePackageProductResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeResourcePackageProductResponseBodyData,
            message: 'string',
            orderId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeResourcePackageProductResponseBody = DescribeResourcePackageProductResponseBody;
class DescribeResourcePackageProductResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourcePackageProductResponseBody,
        };
    }
}
exports.DescribeResourcePackageProductResponse = DescribeResourcePackageProductResponse;
class DescribeResourceUsageDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            periodType: 'PeriodType',
            resourceType: 'ResourceType',
            startPeriod: 'StartPeriod',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            maxResults: 'number',
            nextToken: 'string',
            periodType: 'string',
            resourceType: 'string',
            startPeriod: 'string',
        };
    }
}
exports.DescribeResourceUsageDetailRequest = DescribeResourceUsageDetailRequest;
class DescribeResourceUsageDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeResourceUsageDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeResourceUsageDetailResponseBody = DescribeResourceUsageDetailResponseBody;
class DescribeResourceUsageDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourceUsageDetailResponseBody,
        };
    }
}
exports.DescribeResourceUsageDetailResponse = DescribeResourceUsageDetailResponse;
class DescribeResourceUsageTotalRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            periodType: 'PeriodType',
            resourceType: 'ResourceType',
            startPeriod: 'StartPeriod',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            periodType: 'string',
            resourceType: 'string',
            startPeriod: 'string',
        };
    }
}
exports.DescribeResourceUsageTotalRequest = DescribeResourceUsageTotalRequest;
class DescribeResourceUsageTotalResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeResourceUsageTotalResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeResourceUsageTotalResponseBody = DescribeResourceUsageTotalResponseBody;
class DescribeResourceUsageTotalResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourceUsageTotalResponseBody,
        };
    }
}
exports.DescribeResourceUsageTotalResponse = DescribeResourceUsageTotalResponse;
class DescribeSavingsPlansCoverageDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            maxResults: 'MaxResults',
            periodType: 'PeriodType',
            startPeriod: 'StartPeriod',
            token: 'Token',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            maxResults: 'number',
            periodType: 'string',
            startPeriod: 'string',
            token: 'string',
        };
    }
}
exports.DescribeSavingsPlansCoverageDetailRequest = DescribeSavingsPlansCoverageDetailRequest;
class DescribeSavingsPlansCoverageDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeSavingsPlansCoverageDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeSavingsPlansCoverageDetailResponseBody = DescribeSavingsPlansCoverageDetailResponseBody;
class DescribeSavingsPlansCoverageDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSavingsPlansCoverageDetailResponseBody,
        };
    }
}
exports.DescribeSavingsPlansCoverageDetailResponse = DescribeSavingsPlansCoverageDetailResponse;
class DescribeSavingsPlansCoverageTotalRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            periodType: 'PeriodType',
            startPeriod: 'StartPeriod',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            periodType: 'string',
            startPeriod: 'string',
        };
    }
}
exports.DescribeSavingsPlansCoverageTotalRequest = DescribeSavingsPlansCoverageTotalRequest;
class DescribeSavingsPlansCoverageTotalResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeSavingsPlansCoverageTotalResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeSavingsPlansCoverageTotalResponseBody = DescribeSavingsPlansCoverageTotalResponseBody;
class DescribeSavingsPlansCoverageTotalResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSavingsPlansCoverageTotalResponseBody,
        };
    }
}
exports.DescribeSavingsPlansCoverageTotalResponse = DescribeSavingsPlansCoverageTotalResponse;
class DescribeSavingsPlansUsageDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            maxResults: 'MaxResults',
            periodType: 'PeriodType',
            startPeriod: 'StartPeriod',
            token: 'Token',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            maxResults: 'number',
            periodType: 'string',
            startPeriod: 'string',
            token: 'string',
        };
    }
}
exports.DescribeSavingsPlansUsageDetailRequest = DescribeSavingsPlansUsageDetailRequest;
class DescribeSavingsPlansUsageDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeSavingsPlansUsageDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeSavingsPlansUsageDetailResponseBody = DescribeSavingsPlansUsageDetailResponseBody;
class DescribeSavingsPlansUsageDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSavingsPlansUsageDetailResponseBody,
        };
    }
}
exports.DescribeSavingsPlansUsageDetailResponse = DescribeSavingsPlansUsageDetailResponse;
class DescribeSavingsPlansUsageTotalRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            endPeriod: 'EndPeriod',
            periodType: 'PeriodType',
            startPeriod: 'StartPeriod',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            endPeriod: 'string',
            periodType: 'string',
            startPeriod: 'string',
        };
    }
}
exports.DescribeSavingsPlansUsageTotalRequest = DescribeSavingsPlansUsageTotalRequest;
class DescribeSavingsPlansUsageTotalResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeSavingsPlansUsageTotalResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeSavingsPlansUsageTotalResponseBody = DescribeSavingsPlansUsageTotalResponseBody;
class DescribeSavingsPlansUsageTotalResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSavingsPlansUsageTotalResponseBody,
        };
    }
}
exports.DescribeSavingsPlansUsageTotalResponse = DescribeSavingsPlansUsageTotalResponse;
class DescribeSplitItemBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            billingDate: 'BillingDate',
            granularity: 'Granularity',
            instanceID: 'InstanceID',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            splitItemID: 'SplitItemID',
            subscriptionType: 'SubscriptionType',
            tagFilter: 'TagFilter',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            billingDate: 'string',
            granularity: 'string',
            instanceID: 'string',
            maxResults: 'number',
            nextToken: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            splitItemID: 'string',
            subscriptionType: 'string',
            tagFilter: { 'type': 'array', 'itemType': DescribeSplitItemBillRequestTagFilter },
        };
    }
}
exports.DescribeSplitItemBillRequest = DescribeSplitItemBillRequest;
class DescribeSplitItemBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeSplitItemBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeSplitItemBillResponseBody = DescribeSplitItemBillResponseBody;
class DescribeSplitItemBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSplitItemBillResponseBody,
        };
    }
}
exports.DescribeSplitItemBillResponse = DescribeSplitItemBillResponse;
class EnableBillGenerationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            productCode: 'string',
        };
    }
}
exports.EnableBillGenerationRequest = EnableBillGenerationRequest;
class EnableBillGenerationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: EnableBillGenerationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.EnableBillGenerationResponseBody = EnableBillGenerationResponseBody;
class EnableBillGenerationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EnableBillGenerationResponseBody,
        };
    }
}
exports.EnableBillGenerationResponse = EnableBillGenerationResponse;
class GetAccountRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationId: 'RelationId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            relationId: 'number',
            requestId: 'string',
        };
    }
}
exports.GetAccountRelationRequest = GetAccountRelationRequest;
class GetAccountRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetAccountRelationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetAccountRelationResponseBody = GetAccountRelationResponseBody;
class GetAccountRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAccountRelationResponseBody,
        };
    }
}
exports.GetAccountRelationResponse = GetAccountRelationResponse;
class GetCustomerAccountInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
        };
    }
}
exports.GetCustomerAccountInfoRequest = GetCustomerAccountInfoRequest;
class GetCustomerAccountInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetCustomerAccountInfoResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetCustomerAccountInfoResponseBody = GetCustomerAccountInfoResponseBody;
class GetCustomerAccountInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCustomerAccountInfoResponseBody,
        };
    }
}
exports.GetCustomerAccountInfoResponse = GetCustomerAccountInfoResponse;
class GetCustomerListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetCustomerListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetCustomerListResponseBody = GetCustomerListResponseBody;
class GetCustomerListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCustomerListResponseBody,
        };
    }
}
exports.GetCustomerListResponse = GetCustomerListResponse;
class GetOrderDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            orderId: 'string',
            ownerId: 'number',
        };
    }
}
exports.GetOrderDetailRequest = GetOrderDetailRequest;
class GetOrderDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetOrderDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetOrderDetailResponseBody = GetOrderDetailResponseBody;
class GetOrderDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOrderDetailResponseBody,
        };
    }
}
exports.GetOrderDetailResponse = GetOrderDetailResponse;
class GetPayAsYouGoPriceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            moduleList: 'ModuleList',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            region: 'Region',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            moduleList: { 'type': 'array', 'itemType': GetPayAsYouGoPriceRequestModuleList },
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            region: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.GetPayAsYouGoPriceRequest = GetPayAsYouGoPriceRequest;
class GetPayAsYouGoPriceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetPayAsYouGoPriceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetPayAsYouGoPriceResponseBody = GetPayAsYouGoPriceResponseBody;
class GetPayAsYouGoPriceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPayAsYouGoPriceResponseBody,
        };
    }
}
exports.GetPayAsYouGoPriceResponse = GetPayAsYouGoPriceResponse;
class GetResourcePackagePriceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'Duration',
            effectiveDate: 'EffectiveDate',
            instanceId: 'InstanceId',
            orderType: 'OrderType',
            ownerId: 'OwnerId',
            packageType: 'PackageType',
            pricingCycle: 'PricingCycle',
            productCode: 'ProductCode',
            specification: 'Specification',
        };
    }
    static types() {
        return {
            duration: 'number',
            effectiveDate: 'string',
            instanceId: 'string',
            orderType: 'string',
            ownerId: 'number',
            packageType: 'string',
            pricingCycle: 'string',
            productCode: 'string',
            specification: 'string',
        };
    }
}
exports.GetResourcePackagePriceRequest = GetResourcePackagePriceRequest;
class GetResourcePackagePriceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetResourcePackagePriceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetResourcePackagePriceResponseBody = GetResourcePackagePriceResponseBody;
class GetResourcePackagePriceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetResourcePackagePriceResponseBody,
        };
    }
}
exports.GetResourcePackagePriceResponse = GetResourcePackagePriceResponse;
class GetSubscriptionPriceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            moduleList: 'ModuleList',
            orderType: 'OrderType',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            quantity: 'Quantity',
            region: 'Region',
            servicePeriodQuantity: 'ServicePeriodQuantity',
            servicePeriodUnit: 'ServicePeriodUnit',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            moduleList: { 'type': 'array', 'itemType': GetSubscriptionPriceRequestModuleList },
            orderType: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            quantity: 'number',
            region: 'string',
            servicePeriodQuantity: 'number',
            servicePeriodUnit: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.GetSubscriptionPriceRequest = GetSubscriptionPriceRequest;
class GetSubscriptionPriceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetSubscriptionPriceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetSubscriptionPriceResponseBody = GetSubscriptionPriceResponseBody;
class GetSubscriptionPriceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSubscriptionPriceResponseBody,
        };
    }
}
exports.GetSubscriptionPriceResponse = GetSubscriptionPriceResponse;
class InquiryPriceRefundInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            instanceId: 'InstanceId',
            productCode: 'ProductCode',
            productType: 'ProductType',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            instanceId: 'string',
            productCode: 'string',
            productType: 'string',
        };
    }
}
exports.InquiryPriceRefundInstanceRequest = InquiryPriceRefundInstanceRequest;
class InquiryPriceRefundInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: InquiryPriceRefundInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.InquiryPriceRefundInstanceResponseBody = InquiryPriceRefundInstanceResponseBody;
class InquiryPriceRefundInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InquiryPriceRefundInstanceResponseBody,
        };
    }
}
exports.InquiryPriceRefundInstanceResponse = InquiryPriceRefundInstanceResponse;
class ModifyAccountRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            childNick: 'ChildNick',
            childUserId: 'ChildUserId',
            parentUserId: 'ParentUserId',
            permissionCodes: 'PermissionCodes',
            relationId: 'RelationId',
            relationOperation: 'RelationOperation',
            relationType: 'RelationType',
            requestId: 'RequestId',
            roleCodes: 'RoleCodes',
        };
    }
    static types() {
        return {
            childNick: 'string',
            childUserId: 'number',
            parentUserId: 'number',
            permissionCodes: { 'type': 'array', 'itemType': 'string' },
            relationId: 'number',
            relationOperation: 'string',
            relationType: 'string',
            requestId: 'string',
            roleCodes: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ModifyAccountRelationRequest = ModifyAccountRelationRequest;
class ModifyAccountRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ModifyAccountRelationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ModifyAccountRelationResponseBody = ModifyAccountRelationResponseBody;
class ModifyAccountRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyAccountRelationResponseBody,
        };
    }
}
exports.ModifyAccountRelationResponse = ModifyAccountRelationResponse;
class ModifyCostUnitRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unitEntityList: 'UnitEntityList',
        };
    }
    static types() {
        return {
            unitEntityList: { 'type': 'array', 'itemType': ModifyCostUnitRequestUnitEntityList },
        };
    }
}
exports.ModifyCostUnitRequest = ModifyCostUnitRequest;
class ModifyCostUnitResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: { 'type': 'array', 'itemType': ModifyCostUnitResponseBodyData },
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ModifyCostUnitResponseBody = ModifyCostUnitResponseBody;
class ModifyCostUnitResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyCostUnitResponseBody,
        };
    }
}
exports.ModifyCostUnitResponse = ModifyCostUnitResponse;
class ModifyInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            instanceId: 'InstanceId',
            modifyType: 'ModifyType',
            ownerId: 'OwnerId',
            parameter: 'Parameter',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            instanceId: 'string',
            modifyType: 'string',
            ownerId: 'number',
            parameter: { 'type': 'array', 'itemType': ModifyInstanceRequestParameter },
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.ModifyInstanceRequest = ModifyInstanceRequest;
class ModifyInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ModifyInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ModifyInstanceResponseBody = ModifyInstanceResponseBody;
class ModifyInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyInstanceResponseBody,
        };
    }
}
exports.ModifyInstanceResponse = ModifyInstanceResponse;
class QueryAccountBalanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryAccountBalanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryAccountBalanceResponseBody = QueryAccountBalanceResponseBody;
class QueryAccountBalanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAccountBalanceResponseBody,
        };
    }
}
exports.QueryAccountBalanceResponse = QueryAccountBalanceResponse;
class QueryAccountBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            billingDate: 'BillingDate',
            granularity: 'Granularity',
            isGroupByProduct: 'IsGroupByProduct',
            ownerID: 'OwnerID',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            billingDate: 'string',
            granularity: 'string',
            isGroupByProduct: 'boolean',
            ownerID: 'number',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
        };
    }
}
exports.QueryAccountBillRequest = QueryAccountBillRequest;
class QueryAccountBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryAccountBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryAccountBillResponseBody = QueryAccountBillResponseBody;
class QueryAccountBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAccountBillResponseBody,
        };
    }
}
exports.QueryAccountBillResponse = QueryAccountBillResponse;
class QueryAccountTransactionDetailsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTimeEnd: 'CreateTimeEnd',
            createTimeStart: 'CreateTimeStart',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            recordID: 'RecordID',
            transactionChannel: 'TransactionChannel',
            transactionChannelSN: 'TransactionChannelSN',
            transactionNumber: 'TransactionNumber',
            transactionType: 'TransactionType',
        };
    }
    static types() {
        return {
            createTimeEnd: 'string',
            createTimeStart: 'string',
            maxResults: 'number',
            nextToken: 'string',
            recordID: 'string',
            transactionChannel: 'string',
            transactionChannelSN: 'string',
            transactionNumber: 'string',
            transactionType: 'string',
        };
    }
}
exports.QueryAccountTransactionDetailsRequest = QueryAccountTransactionDetailsRequest;
class QueryAccountTransactionDetailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryAccountTransactionDetailsResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryAccountTransactionDetailsResponseBody = QueryAccountTransactionDetailsResponseBody;
class QueryAccountTransactionDetailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAccountTransactionDetailsResponseBody,
        };
    }
}
exports.QueryAccountTransactionDetailsResponse = QueryAccountTransactionDetailsResponse;
class QueryAccountTransactionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTimeEnd: 'CreateTimeEnd',
            createTimeStart: 'CreateTimeStart',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            recordID: 'RecordID',
            transactionChannel: 'TransactionChannel',
            transactionChannelSN: 'TransactionChannelSN',
            transactionFlow: 'TransactionFlow',
            transactionNumber: 'TransactionNumber',
            transactionType: 'TransactionType',
        };
    }
    static types() {
        return {
            createTimeEnd: 'string',
            createTimeStart: 'string',
            pageNum: 'number',
            pageSize: 'number',
            recordID: 'string',
            transactionChannel: 'string',
            transactionChannelSN: 'string',
            transactionFlow: 'string',
            transactionNumber: 'string',
            transactionType: 'string',
        };
    }
}
exports.QueryAccountTransactionsRequest = QueryAccountTransactionsRequest;
class QueryAccountTransactionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryAccountTransactionsResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryAccountTransactionsResponseBody = QueryAccountTransactionsResponseBody;
class QueryAccountTransactionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAccountTransactionsResponseBody,
        };
    }
}
exports.QueryAccountTransactionsResponse = QueryAccountTransactionsResponse;
class QueryAvailableInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTimeEnd: 'CreateTimeEnd',
            createTimeStart: 'CreateTimeStart',
            endTimeEnd: 'EndTimeEnd',
            endTimeStart: 'EndTimeStart',
            instanceIDs: 'InstanceIDs',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
            productType: 'ProductType',
            region: 'Region',
            renewStatus: 'RenewStatus',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            createTimeEnd: 'string',
            createTimeStart: 'string',
            endTimeEnd: 'string',
            endTimeStart: 'string',
            instanceIDs: 'string',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
            productType: 'string',
            region: 'string',
            renewStatus: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryAvailableInstancesRequest = QueryAvailableInstancesRequest;
class QueryAvailableInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryAvailableInstancesResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryAvailableInstancesResponseBody = QueryAvailableInstancesResponseBody;
class QueryAvailableInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAvailableInstancesResponseBody,
        };
    }
}
exports.QueryAvailableInstancesResponse = QueryAvailableInstancesResponse;
class QueryBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            isDisplayLocalCurrency: 'IsDisplayLocalCurrency',
            isHideZeroCharge: 'IsHideZeroCharge',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
            type: 'Type',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            isDisplayLocalCurrency: 'boolean',
            isHideZeroCharge: 'boolean',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
            type: 'string',
        };
    }
}
exports.QueryBillRequest = QueryBillRequest;
class QueryBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryBillResponseBody = QueryBillResponseBody;
class QueryBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryBillResponseBody,
        };
    }
}
exports.QueryBillResponse = QueryBillResponse;
class QueryBillOverviewRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryBillOverviewRequest = QueryBillOverviewRequest;
class QueryBillOverviewResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryBillOverviewResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryBillOverviewResponseBody = QueryBillOverviewResponseBody;
class QueryBillOverviewResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryBillOverviewResponseBody,
        };
    }
}
exports.QueryBillOverviewResponse = QueryBillOverviewResponse;
class QueryBillToOSSSubscriptionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryBillToOSSSubscriptionResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryBillToOSSSubscriptionResponseBody = QueryBillToOSSSubscriptionResponseBody;
class QueryBillToOSSSubscriptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryBillToOSSSubscriptionResponseBody,
        };
    }
}
exports.QueryBillToOSSSubscriptionResponse = QueryBillToOSSSubscriptionResponse;
class QueryCashCouponsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            effectiveOrNot: 'EffectiveOrNot',
            expiryTimeEnd: 'ExpiryTimeEnd',
            expiryTimeStart: 'ExpiryTimeStart',
        };
    }
    static types() {
        return {
            effectiveOrNot: 'boolean',
            expiryTimeEnd: 'string',
            expiryTimeStart: 'string',
        };
    }
}
exports.QueryCashCouponsRequest = QueryCashCouponsRequest;
class QueryCashCouponsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCashCouponsResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryCashCouponsResponseBody = QueryCashCouponsResponseBody;
class QueryCashCouponsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCashCouponsResponseBody,
        };
    }
}
exports.QueryCashCouponsResponse = QueryCashCouponsResponse;
class QueryCommodityListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productCode: 'ProductCode',
        };
    }
    static types() {
        return {
            productCode: 'string',
        };
    }
}
exports.QueryCommodityListRequest = QueryCommodityListRequest;
class QueryCommodityListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCommodityListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryCommodityListResponseBody = QueryCommodityListResponseBody;
class QueryCommodityListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCommodityListResponseBody,
        };
    }
}
exports.QueryCommodityListResponse = QueryCommodityListResponse;
class QueryCostUnitRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            parentUnitId: 'ParentUnitId',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            pageNum: 'number',
            pageSize: 'number',
            parentUnitId: 'number',
        };
    }
}
exports.QueryCostUnitRequest = QueryCostUnitRequest;
class QueryCostUnitResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCostUnitResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryCostUnitResponseBody = QueryCostUnitResponseBody;
class QueryCostUnitResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCostUnitResponseBody,
        };
    }
}
exports.QueryCostUnitResponse = QueryCostUnitResponse;
class QueryCostUnitResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            unitId: 'UnitId',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            pageNum: 'number',
            pageSize: 'number',
            unitId: 'number',
        };
    }
}
exports.QueryCostUnitResourceRequest = QueryCostUnitResourceRequest;
class QueryCostUnitResourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCostUnitResourceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryCostUnitResourceResponseBody = QueryCostUnitResourceResponseBody;
class QueryCostUnitResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCostUnitResourceResponseBody,
        };
    }
}
exports.QueryCostUnitResourceResponse = QueryCostUnitResourceResponse;
class QueryCustomerAddressListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
        };
    }
}
exports.QueryCustomerAddressListRequest = QueryCustomerAddressListRequest;
class QueryCustomerAddressListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryCustomerAddressListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryCustomerAddressListResponseBody = QueryCustomerAddressListResponseBody;
class QueryCustomerAddressListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCustomerAddressListResponseBody,
        };
    }
}
exports.QueryCustomerAddressListResponse = QueryCustomerAddressListResponse;
class QueryDPUtilizationDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
            deductedInstanceId: 'DeductedInstanceId',
            endTime: 'EndTime',
            includeShare: 'IncludeShare',
            instanceId: 'InstanceId',
            instanceSpec: 'InstanceSpec',
            lastToken: 'LastToken',
            limit: 'Limit',
            prodCode: 'ProdCode',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
            deductedInstanceId: 'string',
            endTime: 'string',
            includeShare: 'boolean',
            instanceId: 'string',
            instanceSpec: 'string',
            lastToken: 'string',
            limit: 'number',
            prodCode: 'string',
            startTime: 'string',
        };
    }
}
exports.QueryDPUtilizationDetailRequest = QueryDPUtilizationDetailRequest;
class QueryDPUtilizationDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryDPUtilizationDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryDPUtilizationDetailResponseBody = QueryDPUtilizationDetailResponseBody;
class QueryDPUtilizationDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDPUtilizationDetailResponseBody,
        };
    }
}
exports.QueryDPUtilizationDetailResponse = QueryDPUtilizationDetailResponse;
class QueryEvaluateListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billCycle: 'BillCycle',
            bizTypeList: 'BizTypeList',
            endAmount: 'EndAmount',
            endBizTime: 'EndBizTime',
            endSearchTime: 'EndSearchTime',
            outBizId: 'OutBizId',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            sortType: 'SortType',
            startAmount: 'StartAmount',
            startBizTime: 'StartBizTime',
            startSearchTime: 'StartSearchTime',
            type: 'Type',
        };
    }
    static types() {
        return {
            billCycle: 'string',
            bizTypeList: { 'type': 'array', 'itemType': 'string' },
            endAmount: 'number',
            endBizTime: 'string',
            endSearchTime: 'string',
            outBizId: 'string',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            sortType: 'number',
            startAmount: 'number',
            startBizTime: 'string',
            startSearchTime: 'string',
            type: 'number',
        };
    }
}
exports.QueryEvaluateListRequest = QueryEvaluateListRequest;
class QueryEvaluateListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryEvaluateListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryEvaluateListResponseBody = QueryEvaluateListResponseBody;
class QueryEvaluateListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryEvaluateListResponseBody,
        };
    }
}
exports.QueryEvaluateListResponse = QueryEvaluateListResponse;
class QueryFinancialAccountInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'UserId',
        };
    }
    static types() {
        return {
            userId: 'number',
        };
    }
}
exports.QueryFinancialAccountInfoRequest = QueryFinancialAccountInfoRequest;
class QueryFinancialAccountInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryFinancialAccountInfoResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryFinancialAccountInfoResponseBody = QueryFinancialAccountInfoResponseBody;
class QueryFinancialAccountInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryFinancialAccountInfoResponseBody,
        };
    }
}
exports.QueryFinancialAccountInfoResponse = QueryFinancialAccountInfoResponse;
class QueryInstanceBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            billingDate: 'BillingDate',
            granularity: 'Granularity',
            isBillingItem: 'IsBillingItem',
            isHideZeroCharge: 'IsHideZeroCharge',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            billingDate: 'string',
            granularity: 'string',
            isBillingItem: 'boolean',
            isHideZeroCharge: 'boolean',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryInstanceBillRequest = QueryInstanceBillRequest;
class QueryInstanceBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryInstanceBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryInstanceBillResponseBody = QueryInstanceBillResponseBody;
class QueryInstanceBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInstanceBillResponseBody,
        };
    }
}
exports.QueryInstanceBillResponse = QueryInstanceBillResponse;
class QueryInstanceByTagRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceId: 'ResourceId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': QueryInstanceByTagRequestTag },
        };
    }
}
exports.QueryInstanceByTagRequest = QueryInstanceByTagRequest;
class QueryInstanceByTagResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            nextToken: 'NextToken',
            requestId: 'RequestId',
            success: 'Success',
            tagResource: 'TagResource',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            nextToken: 'string',
            requestId: 'string',
            success: 'boolean',
            tagResource: { 'type': 'array', 'itemType': QueryInstanceByTagResponseBodyTagResource },
        };
    }
}
exports.QueryInstanceByTagResponseBody = QueryInstanceByTagResponseBody;
class QueryInstanceByTagResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInstanceByTagResponseBody,
        };
    }
}
exports.QueryInstanceByTagResponse = QueryInstanceByTagResponse;
class QueryInstanceGaapCostRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billingCycle: 'BillingCycle',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billingCycle: 'string',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryInstanceGaapCostRequest = QueryInstanceGaapCostRequest;
class QueryInstanceGaapCostResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryInstanceGaapCostResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryInstanceGaapCostResponseBody = QueryInstanceGaapCostResponseBody;
class QueryInstanceGaapCostResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInstanceGaapCostResponseBody,
        };
    }
}
exports.QueryInstanceGaapCostResponse = QueryInstanceGaapCostResponse;
class QueryInvoicingCustomerListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
        };
    }
}
exports.QueryInvoicingCustomerListRequest = QueryInvoicingCustomerListRequest;
class QueryInvoicingCustomerListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryInvoicingCustomerListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryInvoicingCustomerListResponseBody = QueryInvoicingCustomerListResponseBody;
class QueryInvoicingCustomerListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInvoicingCustomerListResponseBody,
        };
    }
}
exports.QueryInvoicingCustomerListResponse = QueryInvoicingCustomerListResponse;
class QueryOrdersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTimeEnd: 'CreateTimeEnd',
            createTimeStart: 'CreateTimeStart',
            orderType: 'OrderType',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            paymentStatus: 'PaymentStatus',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            createTimeEnd: 'string',
            createTimeStart: 'string',
            orderType: 'string',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            paymentStatus: 'string',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryOrdersRequest = QueryOrdersRequest;
class QueryOrdersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryOrdersResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryOrdersResponseBody = QueryOrdersResponseBody;
class QueryOrdersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOrdersResponseBody,
        };
    }
}
exports.QueryOrdersResponse = QueryOrdersResponse;
class QueryPermissionListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationId: 'RelationId',
        };
    }
    static types() {
        return {
            relationId: 'number',
        };
    }
}
exports.QueryPermissionListRequest = QueryPermissionListRequest;
class QueryPermissionListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryPermissionListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryPermissionListResponseBody = QueryPermissionListResponseBody;
class QueryPermissionListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPermissionListResponseBody,
        };
    }
}
exports.QueryPermissionListResponse = QueryPermissionListResponse;
class QueryPrepaidCardsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            effectiveOrNot: 'EffectiveOrNot',
            expiryTimeEnd: 'ExpiryTimeEnd',
            expiryTimeStart: 'ExpiryTimeStart',
        };
    }
    static types() {
        return {
            effectiveOrNot: 'boolean',
            expiryTimeEnd: 'string',
            expiryTimeStart: 'string',
        };
    }
}
exports.QueryPrepaidCardsRequest = QueryPrepaidCardsRequest;
class QueryPrepaidCardsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryPrepaidCardsResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryPrepaidCardsResponseBody = QueryPrepaidCardsResponseBody;
class QueryPrepaidCardsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPrepaidCardsResponseBody,
        };
    }
}
exports.QueryPrepaidCardsResponse = QueryPrepaidCardsResponse;
class QueryPriceEntityListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
        };
    }
}
exports.QueryPriceEntityListRequest = QueryPriceEntityListRequest;
class QueryPriceEntityListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryPriceEntityListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryPriceEntityListResponseBody = QueryPriceEntityListResponseBody;
class QueryPriceEntityListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPriceEntityListResponseBody,
        };
    }
}
exports.QueryPriceEntityListResponse = QueryPriceEntityListResponse;
class QueryProductListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            queryTotalCount: 'QueryTotalCount',
        };
    }
    static types() {
        return {
            pageNum: 'number',
            pageSize: 'number',
            queryTotalCount: 'boolean',
        };
    }
}
exports.QueryProductListRequest = QueryProductListRequest;
class QueryProductListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryProductListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryProductListResponseBody = QueryProductListResponseBody;
class QueryProductListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryProductListResponseBody,
        };
    }
}
exports.QueryProductListResponse = QueryProductListResponse;
class QueryRIUtilizationDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deductedInstanceId: 'DeductedInstanceId',
            endTime: 'EndTime',
            instanceSpec: 'InstanceSpec',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            RICommodityCode: 'RICommodityCode',
            RIInstanceId: 'RIInstanceId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            deductedInstanceId: 'string',
            endTime: 'string',
            instanceSpec: 'string',
            pageNum: 'number',
            pageSize: 'number',
            RICommodityCode: 'string',
            RIInstanceId: 'string',
            startTime: 'string',
        };
    }
}
exports.QueryRIUtilizationDetailRequest = QueryRIUtilizationDetailRequest;
class QueryRIUtilizationDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryRIUtilizationDetailResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryRIUtilizationDetailResponseBody = QueryRIUtilizationDetailResponseBody;
class QueryRIUtilizationDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRIUtilizationDetailResponseBody,
        };
    }
}
exports.QueryRIUtilizationDetailResponse = QueryRIUtilizationDetailResponse;
class QueryRedeemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            effectiveOrNot: 'EffectiveOrNot',
            expiryTimeEnd: 'ExpiryTimeEnd',
            expiryTimeStart: 'ExpiryTimeStart',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            effectiveOrNot: 'boolean',
            expiryTimeEnd: 'string',
            expiryTimeStart: 'string',
            pageNum: 'number',
            pageSize: 'number',
        };
    }
}
exports.QueryRedeemRequest = QueryRedeemRequest;
class QueryRedeemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryRedeemResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryRedeemResponseBody = QueryRedeemResponseBody;
class QueryRedeemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRedeemResponseBody,
        };
    }
}
exports.QueryRedeemResponse = QueryRedeemResponse;
class QueryRelationListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            statusList: 'StatusList',
            userId: 'UserId',
        };
    }
    static types() {
        return {
            pageNum: 'number',
            pageSize: 'number',
            statusList: { 'type': 'array', 'itemType': 'string' },
            userId: 'number',
        };
    }
}
exports.QueryRelationListRequest = QueryRelationListRequest;
class QueryRelationListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryRelationListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryRelationListResponseBody = QueryRelationListResponseBody;
class QueryRelationListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRelationListResponseBody,
        };
    }
}
exports.QueryRelationListResponse = QueryRelationListResponse;
class QueryResellerAvailableQuotaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            itemCodes: 'ItemCodes',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            itemCodes: 'string',
            ownerId: 'number',
        };
    }
}
exports.QueryResellerAvailableQuotaRequest = QueryResellerAvailableQuotaRequest;
class QueryResellerAvailableQuotaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryResellerAvailableQuotaResponseBody = QueryResellerAvailableQuotaResponseBody;
class QueryResellerAvailableQuotaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryResellerAvailableQuotaResponseBody,
        };
    }
}
exports.QueryResellerAvailableQuotaResponse = QueryResellerAvailableQuotaResponse;
class QueryResellerUserAlarmThresholdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alarmType: 'AlarmType',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            alarmType: 'string',
            ownerId: 'number',
        };
    }
}
exports.QueryResellerUserAlarmThresholdRequest = QueryResellerUserAlarmThresholdRequest;
class QueryResellerUserAlarmThresholdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            count: 'Count',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            count: 'number',
            data: { 'type': 'array', 'itemType': QueryResellerUserAlarmThresholdResponseBodyData },
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryResellerUserAlarmThresholdResponseBody = QueryResellerUserAlarmThresholdResponseBody;
class QueryResellerUserAlarmThresholdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryResellerUserAlarmThresholdResponseBody,
        };
    }
}
exports.QueryResellerUserAlarmThresholdResponse = QueryResellerUserAlarmThresholdResponse;
class QueryResourcePackageInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expiryTimeEnd: 'ExpiryTimeEnd',
            expiryTimeStart: 'ExpiryTimeStart',
            includePartner: 'IncludePartner',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
        };
    }
    static types() {
        return {
            expiryTimeEnd: 'string',
            expiryTimeStart: 'string',
            includePartner: 'boolean',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
        };
    }
}
exports.QueryResourcePackageInstancesRequest = QueryResourcePackageInstancesRequest;
class QueryResourcePackageInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            page: 'Page',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            success: 'Success',
            total: 'Total',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryResourcePackageInstancesResponseBodyData,
            message: 'string',
            page: 'number',
            pageSize: 'number',
            requestId: 'string',
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.QueryResourcePackageInstancesResponseBody = QueryResourcePackageInstancesResponseBody;
class QueryResourcePackageInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryResourcePackageInstancesResponseBody,
        };
    }
}
exports.QueryResourcePackageInstancesResponse = QueryResourcePackageInstancesResponse;
class QuerySavingsPlansDeductLogRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            instanceId: 'InstanceId',
            instanceType: 'InstanceType',
            locale: 'Locale',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            endTime: 'string',
            instanceId: 'string',
            instanceType: 'string',
            locale: 'string',
            pageNum: 'number',
            pageSize: 'number',
            startTime: 'string',
        };
    }
}
exports.QuerySavingsPlansDeductLogRequest = QuerySavingsPlansDeductLogRequest;
class QuerySavingsPlansDeductLogResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySavingsPlansDeductLogResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySavingsPlansDeductLogResponseBody = QuerySavingsPlansDeductLogResponseBody;
class QuerySavingsPlansDeductLogResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySavingsPlansDeductLogResponseBody,
        };
    }
}
exports.QuerySavingsPlansDeductLogResponse = QuerySavingsPlansDeductLogResponse;
class QuerySavingsPlansDiscountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
            cycle: 'Cycle',
            locale: 'Locale',
            moduleCode: 'ModuleCode',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            payMode: 'PayMode',
            region: 'Region',
            spec: 'Spec',
            spnType: 'SpnType',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
            cycle: 'string',
            locale: 'string',
            moduleCode: 'string',
            pageNum: 'number',
            pageSize: 'number',
            payMode: 'string',
            region: 'string',
            spec: 'string',
            spnType: 'string',
        };
    }
}
exports.QuerySavingsPlansDiscountRequest = QuerySavingsPlansDiscountRequest;
class QuerySavingsPlansDiscountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySavingsPlansDiscountResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySavingsPlansDiscountResponseBody = QuerySavingsPlansDiscountResponseBody;
class QuerySavingsPlansDiscountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySavingsPlansDiscountResponseBody,
        };
    }
}
exports.QuerySavingsPlansDiscountResponse = QuerySavingsPlansDiscountResponse;
class QuerySavingsPlansInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            instanceId: 'InstanceId',
            locale: 'Locale',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            startTime: 'StartTime',
            status: 'Status',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            endTime: 'string',
            instanceId: 'string',
            locale: 'string',
            pageNum: 'number',
            pageSize: 'number',
            startTime: 'string',
            status: 'string',
            tag: { 'type': 'array', 'itemType': QuerySavingsPlansInstanceRequestTag },
        };
    }
}
exports.QuerySavingsPlansInstanceRequest = QuerySavingsPlansInstanceRequest;
class QuerySavingsPlansInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySavingsPlansInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySavingsPlansInstanceResponseBody = QuerySavingsPlansInstanceResponseBody;
class QuerySavingsPlansInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySavingsPlansInstanceResponseBody,
        };
    }
}
exports.QuerySavingsPlansInstanceResponse = QuerySavingsPlansInstanceResponse;
class QuerySettleBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            isDisplayLocalCurrency: 'IsDisplayLocalCurrency',
            isHideZeroCharge: 'IsHideZeroCharge',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            recordID: 'RecordID',
            subscriptionType: 'SubscriptionType',
            type: 'Type',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            isDisplayLocalCurrency: 'boolean',
            isHideZeroCharge: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            recordID: 'string',
            subscriptionType: 'string',
            type: 'string',
        };
    }
}
exports.QuerySettleBillRequest = QuerySettleBillRequest;
class QuerySettleBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySettleBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySettleBillResponseBody = QuerySettleBillResponseBody;
class QuerySettleBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySettleBillResponseBody,
        };
    }
}
exports.QuerySettleBillResponse = QuerySettleBillResponse;
class QuerySkuPriceListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            priceEntityCode: 'PriceEntityCode',
            priceFactorConditionMap: 'PriceFactorConditionMap',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            priceEntityCode: 'string',
            priceFactorConditionMap: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': 'string' } },
        };
    }
}
exports.QuerySkuPriceListRequest = QuerySkuPriceListRequest;
class QuerySkuPriceListShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityCode: 'CommodityCode',
            nextPageToken: 'NextPageToken',
            pageSize: 'PageSize',
            priceEntityCode: 'PriceEntityCode',
            priceFactorConditionMapShrink: 'PriceFactorConditionMap',
        };
    }
    static types() {
        return {
            commodityCode: 'string',
            nextPageToken: 'string',
            pageSize: 'number',
            priceEntityCode: 'string',
            priceFactorConditionMapShrink: 'string',
        };
    }
}
exports.QuerySkuPriceListShrinkRequest = QuerySkuPriceListShrinkRequest;
class QuerySkuPriceListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySkuPriceListResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySkuPriceListResponseBody = QuerySkuPriceListResponseBody;
class QuerySkuPriceListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySkuPriceListResponseBody,
        };
    }
}
exports.QuerySkuPriceListResponse = QuerySkuPriceListResponse;
class QuerySplitItemBillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billOwnerId: 'BillOwnerId',
            billingCycle: 'BillingCycle',
            ownerId: 'OwnerId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productCode: 'ProductCode',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            billOwnerId: 'number',
            billingCycle: 'string',
            ownerId: 'number',
            pageNum: 'number',
            pageSize: 'number',
            productCode: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QuerySplitItemBillRequest = QuerySplitItemBillRequest;
class QuerySplitItemBillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QuerySplitItemBillResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QuerySplitItemBillResponseBody = QuerySplitItemBillResponseBody;
class QuerySplitItemBillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySplitItemBillResponseBody,
        };
    }
}
exports.QuerySplitItemBillResponse = QuerySplitItemBillResponse;
class QueryUserOmsDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataType: 'DataType',
            endTime: 'EndTime',
            marker: 'Marker',
            ownerId: 'OwnerId',
            pageSize: 'PageSize',
            startTime: 'StartTime',
            table: 'Table',
        };
    }
    static types() {
        return {
            dataType: 'string',
            endTime: 'string',
            marker: 'string',
            ownerId: 'number',
            pageSize: 'number',
            startTime: 'string',
            table: 'string',
        };
    }
}
exports.QueryUserOmsDataRequest = QueryUserOmsDataRequest;
class QueryUserOmsDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: QueryUserOmsDataResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryUserOmsDataResponseBody = QueryUserOmsDataResponseBody;
class QueryUserOmsDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUserOmsDataResponseBody,
        };
    }
}
exports.QueryUserOmsDataResponse = QueryUserOmsDataResponse;
class RefundInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            immediatelyRelease: 'ImmediatelyRelease',
            instanceId: 'InstanceId',
            productCode: 'ProductCode',
            productType: 'ProductType',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            immediatelyRelease: 'string',
            instanceId: 'string',
            productCode: 'string',
            productType: 'string',
        };
    }
}
exports.RefundInstanceRequest = RefundInstanceRequest;
class RefundInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RefundInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RefundInstanceResponseBody = RefundInstanceResponseBody;
class RefundInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RefundInstanceResponseBody,
        };
    }
}
exports.RefundInstanceResponse = RefundInstanceResponse;
class ReleaseInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceIds: 'InstanceIds',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            region: 'Region',
            renewStatus: 'RenewStatus',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            instanceIds: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            region: 'string',
            renewStatus: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.ReleaseInstanceRequest = ReleaseInstanceRequest;
class ReleaseInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ReleaseInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ReleaseInstanceResponseBody = ReleaseInstanceResponseBody;
class ReleaseInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseInstanceResponseBody,
        };
    }
}
exports.ReleaseInstanceResponse = ReleaseInstanceResponse;
class RelieveAccountRelationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            childUserId: 'ChildUserId',
            parentUserId: 'ParentUserId',
            relationId: 'RelationId',
            relationType: 'RelationType',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            childUserId: 'number',
            parentUserId: 'number',
            relationId: 'number',
            relationType: 'string',
            requestId: 'string',
        };
    }
}
exports.RelieveAccountRelationRequest = RelieveAccountRelationRequest;
class RelieveAccountRelationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RelieveAccountRelationResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RelieveAccountRelationResponseBody = RelieveAccountRelationResponseBody;
class RelieveAccountRelationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RelieveAccountRelationResponseBody,
        };
    }
}
exports.RelieveAccountRelationResponse = RelieveAccountRelationResponse;
class RenewInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            instanceId: 'InstanceId',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            renewPeriod: 'RenewPeriod',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            instanceId: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            renewPeriod: 'number',
        };
    }
}
exports.RenewInstanceRequest = RenewInstanceRequest;
class RenewInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RenewInstanceResponseBodyData,
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RenewInstanceResponseBody = RenewInstanceResponseBody;
class RenewInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RenewInstanceResponseBody,
        };
    }
}
exports.RenewInstanceResponse = RenewInstanceResponse;
class RenewResourcePackageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'Duration',
            effectiveDate: 'EffectiveDate',
            instanceId: 'InstanceId',
            ownerId: 'OwnerId',
            pricingCycle: 'PricingCycle',
        };
    }
    static types() {
        return {
            duration: 'number',
            effectiveDate: 'string',
            instanceId: 'string',
            ownerId: 'number',
            pricingCycle: 'string',
        };
    }
}
exports.RenewResourcePackageRequest = RenewResourcePackageRequest;
class RenewResourcePackageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RenewResourcePackageResponseBodyData,
            message: 'string',
            orderId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.RenewResourcePackageResponseBody = RenewResourcePackageResponseBody;
class RenewResourcePackageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RenewResourcePackageResponseBody,
        };
    }
}
exports.RenewResourcePackageResponse = RenewResourcePackageResponse;
class SaveUserCreditRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            avoidExpiration: 'AvoidExpiration',
            avoidNotification: 'AvoidNotification',
            avoidPrepaidExpiration: 'AvoidPrepaidExpiration',
            avoidPrepaidNotification: 'AvoidPrepaidNotification',
            creditType: 'CreditType',
            creditValue: 'CreditValue',
            description: 'Description',
            operator: 'Operator',
        };
    }
    static types() {
        return {
            avoidExpiration: 'boolean',
            avoidNotification: 'boolean',
            avoidPrepaidExpiration: 'boolean',
            avoidPrepaidNotification: 'boolean',
            creditType: 'string',
            creditValue: 'string',
            description: 'string',
            operator: 'string',
        };
    }
}
exports.SaveUserCreditRequest = SaveUserCreditRequest;
class SaveUserCreditResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SaveUserCreditResponseBody = SaveUserCreditResponseBody;
class SaveUserCreditResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveUserCreditResponseBody,
        };
    }
}
exports.SaveUserCreditResponse = SaveUserCreditResponse;
class SetAllExpirationDayRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            unifyExpireDay: 'UnifyExpireDay',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            unifyExpireDay: 'string',
        };
    }
}
exports.SetAllExpirationDayRequest = SetAllExpirationDayRequest;
class SetAllExpirationDayResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetAllExpirationDayResponseBody = SetAllExpirationDayResponseBody;
class SetAllExpirationDayResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetAllExpirationDayResponseBody,
        };
    }
}
exports.SetAllExpirationDayResponse = SetAllExpirationDayResponse;
class SetCreditLabelActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionType: 'ActionType',
            clearCycle: 'ClearCycle',
            creditAmount: 'CreditAmount',
            currencyCode: 'CurrencyCode',
            dailyCycle: 'DailyCycle',
            description: 'Description',
            isNeedAddSettleLabel: 'IsNeedAddSettleLabel',
            isNeedAdjustCreditAccount: 'IsNeedAdjustCreditAccount',
            isNeedSaveNotifyRule: 'IsNeedSaveNotifyRule',
            isNeedSetCreditAmount: 'IsNeedSetCreditAmount',
            needNotice: 'NeedNotice',
            newCreateMode: 'NewCreateMode',
            operator: 'Operator',
            requestId: 'RequestId',
            siteCode: 'SiteCode',
            source: 'Source',
            uid: 'Uid',
        };
    }
    static types() {
        return {
            actionType: 'string',
            clearCycle: 'string',
            creditAmount: 'string',
            currencyCode: 'string',
            dailyCycle: 'string',
            description: 'string',
            isNeedAddSettleLabel: 'string',
            isNeedAdjustCreditAccount: 'string',
            isNeedSaveNotifyRule: 'string',
            isNeedSetCreditAmount: 'string',
            needNotice: 'boolean',
            newCreateMode: 'boolean',
            operator: 'string',
            requestId: 'string',
            siteCode: 'string',
            source: 'string',
            uid: 'string',
        };
    }
}
exports.SetCreditLabelActionRequest = SetCreditLabelActionRequest;
class SetCreditLabelActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetCreditLabelActionResponseBody = SetCreditLabelActionResponseBody;
class SetCreditLabelActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetCreditLabelActionResponseBody,
        };
    }
}
exports.SetCreditLabelActionResponse = SetCreditLabelActionResponse;
class SetRenewalRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceIDs: 'InstanceIDs',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            renewalPeriod: 'RenewalPeriod',
            renewalPeriodUnit: 'RenewalPeriodUnit',
            renewalStatus: 'RenewalStatus',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            instanceIDs: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            renewalPeriod: 'number',
            renewalPeriodUnit: 'string',
            renewalStatus: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.SetRenewalRequest = SetRenewalRequest;
class SetRenewalResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetRenewalResponseBody = SetRenewalResponseBody;
class SetRenewalResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetRenewalResponseBody,
        };
    }
}
exports.SetRenewalResponse = SetRenewalResponse;
class SetResellerUserAlarmThresholdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alarmThresholds: 'AlarmThresholds',
            alarmType: 'AlarmType',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            alarmThresholds: 'string',
            alarmType: 'string',
            ownerId: 'number',
        };
    }
}
exports.SetResellerUserAlarmThresholdRequest = SetResellerUserAlarmThresholdRequest;
class SetResellerUserAlarmThresholdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetResellerUserAlarmThresholdResponseBody = SetResellerUserAlarmThresholdResponseBody;
class SetResellerUserAlarmThresholdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetResellerUserAlarmThresholdResponseBody,
        };
    }
}
exports.SetResellerUserAlarmThresholdResponse = SetResellerUserAlarmThresholdResponse;
class SetResellerUserQuotaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'Amount',
            currency: 'Currency',
            outBizId: 'OutBizId',
            ownerId: 'OwnerId',
        };
    }
    static types() {
        return {
            amount: 'string',
            currency: 'string',
            outBizId: 'string',
            ownerId: 'number',
        };
    }
}
exports.SetResellerUserQuotaRequest = SetResellerUserQuotaRequest;
class SetResellerUserQuotaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetResellerUserQuotaResponseBody = SetResellerUserQuotaResponseBody;
class SetResellerUserQuotaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetResellerUserQuotaResponseBody,
        };
    }
}
exports.SetResellerUserQuotaResponse = SetResellerUserQuotaResponse;
class SetResellerUserStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            businessType: 'BusinessType',
            ownerId: 'OwnerId',
            status: 'Status',
            stopMode: 'StopMode',
        };
    }
    static types() {
        return {
            businessType: 'string',
            ownerId: 'string',
            status: 'string',
            stopMode: 'string',
        };
    }
}
exports.SetResellerUserStatusRequest = SetResellerUserStatusRequest;
class SetResellerUserStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SetResellerUserStatusResponseBody = SetResellerUserStatusResponseBody;
class SetResellerUserStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetResellerUserStatusResponseBody,
        };
    }
}
exports.SetResellerUserStatusResponse = SetResellerUserStatusResponse;
class SubscribeBillToOSSRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            beginBillingCycle: 'BeginBillingCycle',
            bucketOwnerId: 'BucketOwnerId',
            bucketPath: 'BucketPath',
            multAccountRelSubscribe: 'MultAccountRelSubscribe',
            rowLimitPerFile: 'RowLimitPerFile',
            subscribeBucket: 'SubscribeBucket',
            subscribeType: 'SubscribeType',
        };
    }
    static types() {
        return {
            beginBillingCycle: 'string',
            bucketOwnerId: 'number',
            bucketPath: 'string',
            multAccountRelSubscribe: 'string',
            rowLimitPerFile: 'number',
            subscribeBucket: 'string',
            subscribeType: 'string',
        };
    }
}
exports.SubscribeBillToOSSRequest = SubscribeBillToOSSRequest;
class SubscribeBillToOSSResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SubscribeBillToOSSResponseBody = SubscribeBillToOSSResponseBody;
class SubscribeBillToOSSResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SubscribeBillToOSSResponseBody,
        };
    }
}
exports.SubscribeBillToOSSResponse = SubscribeBillToOSSResponse;
class TagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceId: 'ResourceId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
        };
    }
}
exports.TagResourcesRequest = TagResourcesRequest;
class TagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.TagResourcesResponseBody = TagResourcesResponseBody;
class TagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TagResourcesResponseBody,
        };
    }
}
exports.TagResourcesResponse = TagResourcesResponse;
class UnsubscribeBillToOSSRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            multAccountRelSubscribe: 'MultAccountRelSubscribe',
            subscribeType: 'SubscribeType',
        };
    }
    static types() {
        return {
            multAccountRelSubscribe: 'string',
            subscribeType: 'string',
        };
    }
}
exports.UnsubscribeBillToOSSRequest = UnsubscribeBillToOSSRequest;
class UnsubscribeBillToOSSResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UnsubscribeBillToOSSResponseBody = UnsubscribeBillToOSSResponseBody;
class UnsubscribeBillToOSSResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnsubscribeBillToOSSResponseBody,
        };
    }
}
exports.UnsubscribeBillToOSSResponse = UnsubscribeBillToOSSResponse;
class UntagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            all: 'All',
            resourceId: 'ResourceId',
            resourceType: 'ResourceType',
            tagKey: 'TagKey',
        };
    }
    static types() {
        return {
            all: 'boolean',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceType: 'string',
            tagKey: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UntagResourcesRequest = UntagResourcesRequest;
class UntagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'boolean',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UntagResourcesResponseBody = UntagResourcesResponseBody;
class UntagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UntagResourcesResponseBody,
        };
    }
}
exports.UntagResourcesResponse = UntagResourcesResponse;
class UpgradeResourcePackageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            effectiveDate: 'EffectiveDate',
            instanceId: 'InstanceId',
            ownerId: 'OwnerId',
            specification: 'Specification',
        };
    }
    static types() {
        return {
            effectiveDate: 'string',
            instanceId: 'string',
            ownerId: 'number',
            specification: 'string',
        };
    }
}
exports.UpgradeResourcePackageRequest = UpgradeResourcePackageRequest;
class UpgradeResourcePackageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: UpgradeResourcePackageResponseBodyData,
            message: 'string',
            orderId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpgradeResourcePackageResponseBody = UpgradeResourcePackageResponseBody;
class UpgradeResourcePackageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeResourcePackageResponseBody,
        };
    }
}
exports.UpgradeResourcePackageResponse = UpgradeResourcePackageResponse;
class AddAccountRelationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            relationId: 'RelationId',
        };
    }
    static types() {
        return {
            hostId: 'string',
            relationId: 'number',
        };
    }
}
exports.AddAccountRelationResponseBodyData = AddAccountRelationResponseBodyData;
class AllocateCostUnitResourceRequestResourceInstanceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apportionCode: 'ApportionCode',
            commodityCode: 'CommodityCode',
            resourceId: 'ResourceId',
            resourceUserId: 'ResourceUserId',
        };
    }
    static types() {
        return {
            apportionCode: 'string',
            commodityCode: 'string',
            resourceId: 'string',
            resourceUserId: 'number',
        };
    }
}
exports.AllocateCostUnitResourceRequestResourceInstanceList = AllocateCostUnitResourceRequestResourceInstanceList;
class AllocateCostUnitResourceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isSuccess: 'IsSuccess',
            toUnitId: 'ToUnitId',
            toUnitUserId: 'ToUnitUserId',
        };
    }
    static types() {
        return {
            isSuccess: 'boolean',
            toUnitId: 'number',
            toUnitUserId: 'number',
        };
    }
}
exports.AllocateCostUnitResourceResponseBodyData = AllocateCostUnitResourceResponseBodyData;
class ApplyInvoiceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invoiceApplyId: 'InvoiceApplyId',
        };
    }
    static types() {
        return {
            invoiceApplyId: 'number',
        };
    }
}
exports.ApplyInvoiceResponseBodyData = ApplyInvoiceResponseBodyData;
class CancelOrderResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
        };
    }
    static types() {
        return {
            hostId: 'string',
        };
    }
}
exports.CancelOrderResponseBodyData = CancelOrderResponseBodyData;
class ConfirmRelationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
        };
    }
    static types() {
        return {
            hostId: 'string',
        };
    }
}
exports.ConfirmRelationResponseBodyData = ConfirmRelationResponseBodyData;
class ConvertChargeTypeResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            orderId: 'string',
        };
    }
}
exports.ConvertChargeTypeResponseBodyData = ConvertChargeTypeResponseBodyData;
class CreateAgAccountResponseBodyAgRelationDto extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mpk: 'Mpk',
            pk: 'Pk',
            ramAdminRoleName: 'RamAdminRoleName',
            type: 'Type',
        };
    }
    static types() {
        return {
            mpk: 'string',
            pk: 'string',
            ramAdminRoleName: 'string',
            type: 'string',
        };
    }
}
exports.CreateAgAccountResponseBodyAgRelationDto = CreateAgAccountResponseBodyAgRelationDto;
class CreateCostUnitRequestUnitEntityList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            parentUnitId: 'ParentUnitId',
            unitName: 'UnitName',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            parentUnitId: 'number',
            unitName: 'string',
        };
    }
}
exports.CreateCostUnitRequestUnitEntityList = CreateCostUnitRequestUnitEntityList;
class CreateCostUnitResponseBodyDataCostUnitDtoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            parentUnitId: 'ParentUnitId',
            unitId: 'UnitId',
            unitName: 'UnitName',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            parentUnitId: 'number',
            unitId: 'number',
            unitName: 'string',
        };
    }
}
exports.CreateCostUnitResponseBodyDataCostUnitDtoList = CreateCostUnitResponseBodyDataCostUnitDtoList;
class CreateCostUnitResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            costUnitDtoList: 'CostUnitDtoList',
        };
    }
    static types() {
        return {
            costUnitDtoList: { 'type': 'array', 'itemType': CreateCostUnitResponseBodyDataCostUnitDtoList },
        };
    }
}
exports.CreateCostUnitResponseBodyData = CreateCostUnitResponseBodyData;
class CreateInstanceRequestParameter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            value: 'Value',
        };
    }
    static types() {
        return {
            code: 'string',
            value: 'string',
        };
    }
}
exports.CreateInstanceRequestParameter = CreateInstanceRequestParameter;
class CreateInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            orderId: 'string',
        };
    }
}
exports.CreateInstanceResponseBodyData = CreateInstanceResponseBodyData;
class CreateResourcePackageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            orderId: 'number',
        };
    }
}
exports.CreateResourcePackageResponseBodyData = CreateResourcePackageResponseBodyData;
class CreateSavingsPlansInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            orderId: 'number',
        };
    }
}
exports.CreateSavingsPlansInstanceResponseBodyData = CreateSavingsPlansInstanceResponseBodyData;
class DeleteCostUnitResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isSuccess: 'IsSuccess',
            ownerUid: 'OwnerUid',
            unitId: 'UnitId',
        };
    }
    static types() {
        return {
            isSuccess: 'boolean',
            ownerUid: 'number',
            unitId: 'number',
        };
    }
}
exports.DeleteCostUnitResponseBodyData = DeleteCostUnitResponseBodyData;
class DescribeCostBudgetsSummaryResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            budget: 'Budget',
            budgetName: 'BudgetName',
            budgetStatus: 'BudgetStatus',
            budgetType: 'BudgetType',
            calculatedValues: 'CalculatedValues',
            consumePeriod: 'ConsumePeriod',
        };
    }
    static types() {
        return {
            budget: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            budgetName: 'string',
            budgetStatus: 'string',
            budgetType: 'string',
            calculatedValues: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            consumePeriod: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.DescribeCostBudgetsSummaryResponseBodyDataItems = DescribeCostBudgetsSummaryResponseBodyDataItems;
class DescribeCostBudgetsSummaryResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            hostId: 'string',
            items: { 'type': 'array', 'itemType': DescribeCostBudgetsSummaryResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeCostBudgetsSummaryResponseBodyData = DescribeCostBudgetsSummaryResponseBodyData;
class DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriod: 'AmortizationPeriod',
            amortizationStatus: 'AmortizationStatus',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billOwnerID: 'BillOwnerID',
            billOwnerName: 'BillOwnerName',
            bizType: 'BizType',
            consumePeriod: 'ConsumePeriod',
            costUnit: 'CostUnit',
            costUnitCode: 'CostUnitCode',
            currentAmortizationDeductedByCashCoupons: 'CurrentAmortizationDeductedByCashCoupons',
            currentAmortizationDeductedByCoupons: 'CurrentAmortizationDeductedByCoupons',
            currentAmortizationDeductedByPrepaidCard: 'CurrentAmortizationDeductedByPrepaidCard',
            currentAmortizationExpenditureAmount: 'CurrentAmortizationExpenditureAmount',
            currentAmortizationInvoiceDiscount: 'CurrentAmortizationInvoiceDiscount',
            currentAmortizationPretaxAmount: 'CurrentAmortizationPretaxAmount',
            currentAmortizationPretaxGrossAmount: 'CurrentAmortizationPretaxGrossAmount',
            currentAmortizationRoundDownDiscount: 'CurrentAmortizationRoundDownDiscount',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            expenditureAmount: 'ExpenditureAmount',
            instanceID: 'InstanceID',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            previouslyAmortizedDeductedByCashCoupons: 'PreviouslyAmortizedDeductedByCashCoupons',
            previouslyAmortizedDeductedByCoupons: 'PreviouslyAmortizedDeductedByCoupons',
            previouslyAmortizedDeductedByPrepaidCard: 'PreviouslyAmortizedDeductedByPrepaidCard',
            previouslyAmortizedExpenditureAmount: 'PreviouslyAmortizedExpenditureAmount',
            previouslyAmortizedInvoiceDiscount: 'PreviouslyAmortizedInvoiceDiscount',
            previouslyAmortizedPretaxAmount: 'PreviouslyAmortizedPretaxAmount',
            previouslyAmortizedPretaxGrossAmount: 'PreviouslyAmortizedPretaxGrossAmount',
            previouslyAmortizedRoundDownDiscount: 'PreviouslyAmortizedRoundDownDiscount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productDetailCode: 'ProductDetailCode',
            productName: 'ProductName',
            region: 'Region',
            remainingAmortizationDeductedByCashCoupons: 'RemainingAmortizationDeductedByCashCoupons',
            remainingAmortizationDeductedByCoupons: 'RemainingAmortizationDeductedByCoupons',
            remainingAmortizationDeductedByPrepaidCard: 'RemainingAmortizationDeductedByPrepaidCard',
            remainingAmortizationExpenditureAmount: 'RemainingAmortizationExpenditureAmount',
            remainingAmortizationInvoiceDiscount: 'RemainingAmortizationInvoiceDiscount',
            remainingAmortizationPretaxAmount: 'RemainingAmortizationPretaxAmount',
            remainingAmortizationPretaxGrossAmount: 'RemainingAmortizationPretaxGrossAmount',
            remainingAmortizationRoundDownDiscount: 'RemainingAmortizationRoundDownDiscount',
            resourceGroup: 'ResourceGroup',
            roundDownDiscount: 'RoundDownDiscount',
            splitAccountName: 'SplitAccountName',
            splitItemID: 'SplitItemID',
            splitItemName: 'SplitItemName',
            splitProductDetail: 'SplitProductDetail',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            amortizationPeriod: 'string',
            amortizationStatus: 'string',
            billAccountID: 'number',
            billAccountName: 'string',
            billOwnerID: 'number',
            billOwnerName: 'string',
            bizType: 'string',
            consumePeriod: 'string',
            costUnit: 'string',
            costUnitCode: 'string',
            currentAmortizationDeductedByCashCoupons: 'number',
            currentAmortizationDeductedByCoupons: 'number',
            currentAmortizationDeductedByPrepaidCard: 'number',
            currentAmortizationExpenditureAmount: 'number',
            currentAmortizationInvoiceDiscount: 'number',
            currentAmortizationPretaxAmount: 'number',
            currentAmortizationPretaxGrossAmount: 'number',
            currentAmortizationRoundDownDiscount: 'number',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            expenditureAmount: 'number',
            instanceID: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            previouslyAmortizedDeductedByCashCoupons: 'number',
            previouslyAmortizedDeductedByCoupons: 'number',
            previouslyAmortizedDeductedByPrepaidCard: 'number',
            previouslyAmortizedExpenditureAmount: 'number',
            previouslyAmortizedInvoiceDiscount: 'number',
            previouslyAmortizedPretaxAmount: 'number',
            previouslyAmortizedPretaxGrossAmount: 'number',
            previouslyAmortizedRoundDownDiscount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productDetailCode: 'string',
            productName: 'string',
            region: 'string',
            remainingAmortizationDeductedByCashCoupons: 'number',
            remainingAmortizationDeductedByCoupons: 'number',
            remainingAmortizationDeductedByPrepaidCard: 'number',
            remainingAmortizationExpenditureAmount: 'number',
            remainingAmortizationInvoiceDiscount: 'number',
            remainingAmortizationPretaxAmount: 'number',
            remainingAmortizationPretaxGrossAmount: 'number',
            remainingAmortizationRoundDownDiscount: 'number',
            resourceGroup: 'string',
            roundDownDiscount: 'number',
            splitAccountName: 'string',
            splitItemID: 'string',
            splitItemName: 'string',
            splitProductDetail: 'string',
            subscriptionType: 'string',
            tag: 'string',
            zone: 'string',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyDataItems = DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyDataItems;
class DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            items: { 'type': 'array', 'itemType': DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyData = DescribeInstanceAmortizedCostByAmortizationPeriodResponseBodyData;
class DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriod: 'AmortizationPeriod',
            amortizationPeriodDay: 'AmortizationPeriodDay',
            amortizationStatus: 'AmortizationStatus',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billOwnerID: 'BillOwnerID',
            billOwnerName: 'BillOwnerName',
            bizType: 'BizType',
            consumePeriod: 'ConsumePeriod',
            consumePeriodDay: 'ConsumePeriodDay',
            costUnit: 'CostUnit',
            costUnitCode: 'CostUnitCode',
            currentAmortizationDeductedByCashCoupons: 'CurrentAmortizationDeductedByCashCoupons',
            currentAmortizationDeductedByCoupons: 'CurrentAmortizationDeductedByCoupons',
            currentAmortizationDeductedByPrepaidCard: 'CurrentAmortizationDeductedByPrepaidCard',
            currentAmortizationExpenditureAmount: 'CurrentAmortizationExpenditureAmount',
            currentAmortizationInvoiceDiscount: 'CurrentAmortizationInvoiceDiscount',
            currentAmortizationPretaxAmount: 'CurrentAmortizationPretaxAmount',
            currentAmortizationPretaxGrossAmount: 'CurrentAmortizationPretaxGrossAmount',
            currentAmortizationRoundDownDiscount: 'CurrentAmortizationRoundDownDiscount',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            expenditureAmount: 'ExpenditureAmount',
            instanceID: 'InstanceID',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            previouslyAmortizedDeductedByCashCoupons: 'PreviouslyAmortizedDeductedByCashCoupons',
            previouslyAmortizedDeductedByCoupons: 'PreviouslyAmortizedDeductedByCoupons',
            previouslyAmortizedDeductedByPrepaidCard: 'PreviouslyAmortizedDeductedByPrepaidCard',
            previouslyAmortizedExpenditureAmount: 'PreviouslyAmortizedExpenditureAmount',
            previouslyAmortizedInvoiceDiscount: 'PreviouslyAmortizedInvoiceDiscount',
            previouslyAmortizedPretaxAmount: 'PreviouslyAmortizedPretaxAmount',
            previouslyAmortizedPretaxGrossAmount: 'PreviouslyAmortizedPretaxGrossAmount',
            previouslyAmortizedRoundDownDiscount: 'PreviouslyAmortizedRoundDownDiscount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productDetailCode: 'ProductDetailCode',
            productName: 'ProductName',
            region: 'Region',
            remainingAmortizationDeductedByCashCoupons: 'RemainingAmortizationDeductedByCashCoupons',
            remainingAmortizationDeductedByCoupons: 'RemainingAmortizationDeductedByCoupons',
            remainingAmortizationDeductedByPrepaidCard: 'RemainingAmortizationDeductedByPrepaidCard',
            remainingAmortizationExpenditureAmount: 'RemainingAmortizationExpenditureAmount',
            remainingAmortizationInvoiceDiscount: 'RemainingAmortizationInvoiceDiscount',
            remainingAmortizationPretaxAmount: 'RemainingAmortizationPretaxAmount',
            remainingAmortizationPretaxGrossAmount: 'RemainingAmortizationPretaxGrossAmount',
            remainingAmortizationRoundDownDiscount: 'RemainingAmortizationRoundDownDiscount',
            resourceGroup: 'ResourceGroup',
            roundDownDiscount: 'RoundDownDiscount',
            splitAccountName: 'SplitAccountName',
            splitItemID: 'SplitItemID',
            splitItemName: 'SplitItemName',
            splitProductDetail: 'SplitProductDetail',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            amortizationPeriod: 'string',
            amortizationPeriodDay: 'string',
            amortizationStatus: 'string',
            billAccountID: 'number',
            billAccountName: 'string',
            billOwnerID: 'number',
            billOwnerName: 'string',
            bizType: 'string',
            consumePeriod: 'string',
            consumePeriodDay: 'string',
            costUnit: 'string',
            costUnitCode: 'string',
            currentAmortizationDeductedByCashCoupons: 'number',
            currentAmortizationDeductedByCoupons: 'number',
            currentAmortizationDeductedByPrepaidCard: 'number',
            currentAmortizationExpenditureAmount: 'number',
            currentAmortizationInvoiceDiscount: 'number',
            currentAmortizationPretaxAmount: 'number',
            currentAmortizationPretaxGrossAmount: 'number',
            currentAmortizationRoundDownDiscount: 'number',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            expenditureAmount: 'number',
            instanceID: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            previouslyAmortizedDeductedByCashCoupons: 'number',
            previouslyAmortizedDeductedByCoupons: 'number',
            previouslyAmortizedDeductedByPrepaidCard: 'number',
            previouslyAmortizedExpenditureAmount: 'number',
            previouslyAmortizedInvoiceDiscount: 'number',
            previouslyAmortizedPretaxAmount: 'number',
            previouslyAmortizedPretaxGrossAmount: 'number',
            previouslyAmortizedRoundDownDiscount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productDetailCode: 'string',
            productName: 'string',
            region: 'string',
            remainingAmortizationDeductedByCashCoupons: 'number',
            remainingAmortizationDeductedByCoupons: 'number',
            remainingAmortizationDeductedByPrepaidCard: 'number',
            remainingAmortizationExpenditureAmount: 'number',
            remainingAmortizationInvoiceDiscount: 'number',
            remainingAmortizationPretaxAmount: 'number',
            remainingAmortizationPretaxGrossAmount: 'number',
            remainingAmortizationRoundDownDiscount: 'number',
            resourceGroup: 'string',
            roundDownDiscount: 'number',
            splitAccountName: 'string',
            splitItemID: 'string',
            splitItemName: 'string',
            splitProductDetail: 'string',
            subscriptionType: 'string',
            tag: 'string',
            zone: 'string',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyDataItems = DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyDataItems;
class DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            hostId: 'HostId',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            hostId: 'string',
            items: { 'type': 'array', 'itemType': DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyData = DescribeInstanceAmortizedCostByAmortizationPeriodDateResponseBodyData;
class DescribeInstanceAmortizedCostByConsumePeriodResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriod: 'AmortizationPeriod',
            amortizationStatus: 'AmortizationStatus',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billOwnerID: 'BillOwnerID',
            billOwnerName: 'BillOwnerName',
            bizType: 'BizType',
            consumePeriod: 'ConsumePeriod',
            costUnit: 'CostUnit',
            costUnitCode: 'CostUnitCode',
            currentAmortizationDeductedByCashCoupons: 'CurrentAmortizationDeductedByCashCoupons',
            currentAmortizationDeductedByCoupons: 'CurrentAmortizationDeductedByCoupons',
            currentAmortizationDeductedByPrepaidCard: 'CurrentAmortizationDeductedByPrepaidCard',
            currentAmortizationExpenditureAmount: 'CurrentAmortizationExpenditureAmount',
            currentAmortizationInvoiceDiscount: 'CurrentAmortizationInvoiceDiscount',
            currentAmortizationPretaxAmount: 'CurrentAmortizationPretaxAmount',
            currentAmortizationPretaxGrossAmount: 'CurrentAmortizationPretaxGrossAmount',
            currentAmortizationRoundDownDiscount: 'CurrentAmortizationRoundDownDiscount',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            expenditureAmount: 'ExpenditureAmount',
            instanceID: 'InstanceID',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            previouslyAmortizedDeductedByCashCoupons: 'PreviouslyAmortizedDeductedByCashCoupons',
            previouslyAmortizedDeductedByCoupons: 'PreviouslyAmortizedDeductedByCoupons',
            previouslyAmortizedDeductedByPrepaidCard: 'PreviouslyAmortizedDeductedByPrepaidCard',
            previouslyAmortizedExpenditureAmount: 'PreviouslyAmortizedExpenditureAmount',
            previouslyAmortizedInvoiceDiscount: 'PreviouslyAmortizedInvoiceDiscount',
            previouslyAmortizedPretaxAmount: 'PreviouslyAmortizedPretaxAmount',
            previouslyAmortizedPretaxGrossAmount: 'PreviouslyAmortizedPretaxGrossAmount',
            previouslyAmortizedRoundDownDiscount: 'PreviouslyAmortizedRoundDownDiscount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productDetailCode: 'ProductDetailCode',
            productName: 'ProductName',
            region: 'Region',
            remainingAmortizationDeductedByCashCoupons: 'RemainingAmortizationDeductedByCashCoupons',
            remainingAmortizationDeductedByCoupons: 'RemainingAmortizationDeductedByCoupons',
            remainingAmortizationDeductedByPrepaidCard: 'RemainingAmortizationDeductedByPrepaidCard',
            remainingAmortizationExpenditureAmount: 'RemainingAmortizationExpenditureAmount',
            remainingAmortizationInvoiceDiscount: 'RemainingAmortizationInvoiceDiscount',
            remainingAmortizationPretaxAmount: 'RemainingAmortizationPretaxAmount',
            remainingAmortizationPretaxGrossAmount: 'RemainingAmortizationPretaxGrossAmount',
            remainingAmortizationRoundDownDiscount: 'RemainingAmortizationRoundDownDiscount',
            resourceGroup: 'ResourceGroup',
            roundDownDiscount: 'RoundDownDiscount',
            splitAccountName: 'SplitAccountName',
            splitItemID: 'SplitItemID',
            splitItemName: 'SplitItemName',
            splitProductDetail: 'SplitProductDetail',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            amortizationPeriod: 'string',
            amortizationStatus: 'string',
            billAccountID: 'number',
            billAccountName: 'string',
            billOwnerID: 'number',
            billOwnerName: 'string',
            bizType: 'string',
            consumePeriod: 'string',
            costUnit: 'string',
            costUnitCode: 'string',
            currentAmortizationDeductedByCashCoupons: 'number',
            currentAmortizationDeductedByCoupons: 'number',
            currentAmortizationDeductedByPrepaidCard: 'number',
            currentAmortizationExpenditureAmount: 'number',
            currentAmortizationInvoiceDiscount: 'number',
            currentAmortizationPretaxAmount: 'number',
            currentAmortizationPretaxGrossAmount: 'number',
            currentAmortizationRoundDownDiscount: 'number',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            expenditureAmount: 'number',
            instanceID: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            previouslyAmortizedDeductedByCashCoupons: 'number',
            previouslyAmortizedDeductedByCoupons: 'number',
            previouslyAmortizedDeductedByPrepaidCard: 'number',
            previouslyAmortizedExpenditureAmount: 'number',
            previouslyAmortizedInvoiceDiscount: 'number',
            previouslyAmortizedPretaxAmount: 'number',
            previouslyAmortizedPretaxGrossAmount: 'number',
            previouslyAmortizedRoundDownDiscount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productDetailCode: 'string',
            productName: 'string',
            region: 'string',
            remainingAmortizationDeductedByCashCoupons: 'number',
            remainingAmortizationDeductedByCoupons: 'number',
            remainingAmortizationDeductedByPrepaidCard: 'number',
            remainingAmortizationExpenditureAmount: 'number',
            remainingAmortizationInvoiceDiscount: 'number',
            remainingAmortizationPretaxAmount: 'number',
            remainingAmortizationPretaxGrossAmount: 'number',
            remainingAmortizationRoundDownDiscount: 'number',
            resourceGroup: 'string',
            roundDownDiscount: 'number',
            splitAccountName: 'string',
            splitItemID: 'string',
            splitItemName: 'string',
            splitProductDetail: 'string',
            subscriptionType: 'string',
            tag: 'string',
            zone: 'string',
        };
    }
}
exports.DescribeInstanceAmortizedCostByConsumePeriodResponseBodyDataItems = DescribeInstanceAmortizedCostByConsumePeriodResponseBodyDataItems;
class DescribeInstanceAmortizedCostByConsumePeriodResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            items: { 'type': 'array', 'itemType': DescribeInstanceAmortizedCostByConsumePeriodResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeInstanceAmortizedCostByConsumePeriodResponseBodyData = DescribeInstanceAmortizedCostByConsumePeriodResponseBodyData;
class DescribeInstanceBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billingDate: 'BillingDate',
            billingItem: 'BillingItem',
            billingItemCode: 'BillingItemCode',
            billingType: 'BillingType',
            bizType: 'BizType',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            costUnit: 'CostUnit',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            deductedByResourcePackage: 'DeductedByResourcePackage',
            instanceConfig: 'InstanceConfig',
            instanceID: 'InstanceID',
            instanceSpec: 'InstanceSpec',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            itemName: 'ItemName',
            listPrice: 'ListPrice',
            listPriceUnit: 'ListPriceUnit',
            nickName: 'NickName',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            region: 'Region',
            resourceGroup: 'ResourceGroup',
            servicePeriod: 'ServicePeriod',
            servicePeriodUnit: 'ServicePeriodUnit',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            usage: 'Usage',
            usageUnit: 'UsageUnit',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            billAccountID: 'string',
            billAccountName: 'string',
            billingDate: 'string',
            billingItem: 'string',
            billingItemCode: 'string',
            billingType: 'string',
            bizType: 'string',
            cashAmount: 'number',
            commodityCode: 'string',
            costUnit: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            deductedByResourcePackage: 'string',
            instanceConfig: 'string',
            instanceID: 'string',
            instanceSpec: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            item: 'string',
            itemName: 'string',
            listPrice: 'string',
            listPriceUnit: 'string',
            nickName: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            region: 'string',
            resourceGroup: 'string',
            servicePeriod: 'string',
            servicePeriodUnit: 'string',
            subscriptionType: 'string',
            tag: 'string',
            usage: 'string',
            usageUnit: 'string',
            zone: 'string',
        };
    }
}
exports.DescribeInstanceBillResponseBodyDataItems = DescribeInstanceBillResponseBodyDataItems;
class DescribeInstanceBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: { 'type': 'array', 'itemType': DescribeInstanceBillResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeInstanceBillResponseBodyData = DescribeInstanceBillResponseBodyData;
class DescribePricingModuleResponseBodyDataAttributeListAttributeValuesAttributeValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            remark: 'Remark',
            type: 'Type',
            value: 'Value',
        };
    }
    static types() {
        return {
            name: 'string',
            remark: 'string',
            type: 'string',
            value: 'string',
        };
    }
}
exports.DescribePricingModuleResponseBodyDataAttributeListAttributeValuesAttributeValue = DescribePricingModuleResponseBodyDataAttributeListAttributeValuesAttributeValue;
class DescribePricingModuleResponseBodyDataAttributeListAttributeValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attributeValue: 'AttributeValue',
        };
    }
    static types() {
        return {
            attributeValue: { 'type': 'array', 'itemType': DescribePricingModuleResponseBodyDataAttributeListAttributeValuesAttributeValue },
        };
    }
}
exports.DescribePricingModuleResponseBodyDataAttributeListAttributeValues = DescribePricingModuleResponseBodyDataAttributeListAttributeValues;
class DescribePricingModuleResponseBodyDataAttributeListAttribute extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            name: 'Name',
            unit: 'Unit',
            values: 'Values',
        };
    }
    static types() {
        return {
            code: 'string',
            name: 'string',
            unit: 'string',
            values: DescribePricingModuleResponseBodyDataAttributeListAttributeValues,
        };
    }
}
exports.DescribePricingModuleResponseBodyDataAttributeListAttribute = DescribePricingModuleResponseBodyDataAttributeListAttribute;
class DescribePricingModuleResponseBodyDataAttributeList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attribute: 'Attribute',
        };
    }
    static types() {
        return {
            attribute: { 'type': 'array', 'itemType': DescribePricingModuleResponseBodyDataAttributeListAttribute },
        };
    }
}
exports.DescribePricingModuleResponseBodyDataAttributeList = DescribePricingModuleResponseBodyDataAttributeList;
class DescribePricingModuleResponseBodyDataModuleListModuleConfigList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configList: 'ConfigList',
        };
    }
    static types() {
        return {
            configList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribePricingModuleResponseBodyDataModuleListModuleConfigList = DescribePricingModuleResponseBodyDataModuleListModuleConfigList;
class DescribePricingModuleResponseBodyDataModuleListModule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configList: 'ConfigList',
            currency: 'Currency',
            moduleCode: 'ModuleCode',
            moduleName: 'ModuleName',
            priceType: 'PriceType',
        };
    }
    static types() {
        return {
            configList: DescribePricingModuleResponseBodyDataModuleListModuleConfigList,
            currency: 'string',
            moduleCode: 'string',
            moduleName: 'string',
            priceType: 'string',
        };
    }
}
exports.DescribePricingModuleResponseBodyDataModuleListModule = DescribePricingModuleResponseBodyDataModuleListModule;
class DescribePricingModuleResponseBodyDataModuleList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            module: 'Module',
        };
    }
    static types() {
        return {
            module: { 'type': 'array', 'itemType': DescribePricingModuleResponseBodyDataModuleListModule },
        };
    }
}
exports.DescribePricingModuleResponseBodyDataModuleList = DescribePricingModuleResponseBodyDataModuleList;
class DescribePricingModuleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attributeList: 'AttributeList',
            moduleList: 'ModuleList',
        };
    }
    static types() {
        return {
            attributeList: DescribePricingModuleResponseBodyDataAttributeList,
            moduleList: DescribePricingModuleResponseBodyDataModuleList,
        };
    }
}
exports.DescribePricingModuleResponseBodyData = DescribePricingModuleResponseBodyData;
class DescribeProductAmortizedCostByAmortizationPeriodResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriod: 'AmortizationPeriod',
            amortizationStatus: 'AmortizationStatus',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billOwnerID: 'BillOwnerID',
            billOwnerName: 'BillOwnerName',
            bizType: 'BizType',
            consumePeriod: 'ConsumePeriod',
            currentAmortizationDeductedByCashCoupons: 'CurrentAmortizationDeductedByCashCoupons',
            currentAmortizationDeductedByCoupons: 'CurrentAmortizationDeductedByCoupons',
            currentAmortizationDeductedByPrepaidCard: 'CurrentAmortizationDeductedByPrepaidCard',
            currentAmortizationExpenditureAmount: 'CurrentAmortizationExpenditureAmount',
            currentAmortizationInvoiceDiscount: 'CurrentAmortizationInvoiceDiscount',
            currentAmortizationPretaxAmount: 'CurrentAmortizationPretaxAmount',
            currentAmortizationPretaxGrossAmount: 'CurrentAmortizationPretaxGrossAmount',
            currentAmortizationRoundDownDiscount: 'CurrentAmortizationRoundDownDiscount',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            expenditureAmount: 'ExpenditureAmount',
            invoiceDiscount: 'InvoiceDiscount',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            previouslyAmortizedDeductedByCashCoupons: 'PreviouslyAmortizedDeductedByCashCoupons',
            previouslyAmortizedDeductedByCoupons: 'PreviouslyAmortizedDeductedByCoupons',
            previouslyAmortizedDeductedByPrepaidCard: 'PreviouslyAmortizedDeductedByPrepaidCard',
            previouslyAmortizedExpenditureAmount: 'PreviouslyAmortizedExpenditureAmount',
            previouslyAmortizedInvoiceDiscount: 'PreviouslyAmortizedInvoiceDiscount',
            previouslyAmortizedPretaxAmount: 'PreviouslyAmortizedPretaxAmount',
            previouslyAmortizedPretaxGrossAmount: 'PreviouslyAmortizedPretaxGrossAmount',
            previouslyAmortizedRoundDownDiscount: 'PreviouslyAmortizedRoundDownDiscount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productDetailCode: 'ProductDetailCode',
            productName: 'ProductName',
            remainingAmortizationDeductedByCashCoupons: 'RemainingAmortizationDeductedByCashCoupons',
            remainingAmortizationDeductedByCoupons: 'RemainingAmortizationDeductedByCoupons',
            remainingAmortizationDeductedByPrepaidCard: 'RemainingAmortizationDeductedByPrepaidCard',
            remainingAmortizationExpenditureAmount: 'RemainingAmortizationExpenditureAmount',
            remainingAmortizationInvoiceDiscount: 'RemainingAmortizationInvoiceDiscount',
            remainingAmortizationPretaxAmount: 'RemainingAmortizationPretaxAmount',
            remainingAmortizationPretaxGrossAmount: 'RemainingAmortizationPretaxGrossAmount',
            remainingAmortizationRoundDownDiscount: 'RemainingAmortizationRoundDownDiscount',
            roundDownDiscount: 'RoundDownDiscount',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            amortizationPeriod: 'string',
            amortizationStatus: 'string',
            billAccountID: 'number',
            billAccountName: 'string',
            billOwnerID: 'number',
            billOwnerName: 'string',
            bizType: 'string',
            consumePeriod: 'string',
            currentAmortizationDeductedByCashCoupons: 'number',
            currentAmortizationDeductedByCoupons: 'number',
            currentAmortizationDeductedByPrepaidCard: 'number',
            currentAmortizationExpenditureAmount: 'number',
            currentAmortizationInvoiceDiscount: 'number',
            currentAmortizationPretaxAmount: 'number',
            currentAmortizationPretaxGrossAmount: 'number',
            currentAmortizationRoundDownDiscount: 'number',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            expenditureAmount: 'number',
            invoiceDiscount: 'number',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            previouslyAmortizedDeductedByCashCoupons: 'number',
            previouslyAmortizedDeductedByCoupons: 'number',
            previouslyAmortizedDeductedByPrepaidCard: 'number',
            previouslyAmortizedExpenditureAmount: 'number',
            previouslyAmortizedInvoiceDiscount: 'number',
            previouslyAmortizedPretaxAmount: 'number',
            previouslyAmortizedPretaxGrossAmount: 'number',
            previouslyAmortizedRoundDownDiscount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productDetailCode: 'string',
            productName: 'string',
            remainingAmortizationDeductedByCashCoupons: 'number',
            remainingAmortizationDeductedByCoupons: 'number',
            remainingAmortizationDeductedByPrepaidCard: 'number',
            remainingAmortizationExpenditureAmount: 'number',
            remainingAmortizationInvoiceDiscount: 'number',
            remainingAmortizationPretaxAmount: 'number',
            remainingAmortizationPretaxGrossAmount: 'number',
            remainingAmortizationRoundDownDiscount: 'number',
            roundDownDiscount: 'number',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeProductAmortizedCostByAmortizationPeriodResponseBodyDataItems = DescribeProductAmortizedCostByAmortizationPeriodResponseBodyDataItems;
class DescribeProductAmortizedCostByAmortizationPeriodResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            items: { 'type': 'array', 'itemType': DescribeProductAmortizedCostByAmortizationPeriodResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeProductAmortizedCostByAmortizationPeriodResponseBodyData = DescribeProductAmortizedCostByAmortizationPeriodResponseBodyData;
class DescribeProductAmortizedCostByConsumePeriodResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amortizationPeriod: 'AmortizationPeriod',
            amortizationStatus: 'AmortizationStatus',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billOwnerID: 'BillOwnerID',
            billOwnerName: 'BillOwnerName',
            bizType: 'BizType',
            consumePeriod: 'ConsumePeriod',
            currentAmortizationDeductedByCashCoupons: 'CurrentAmortizationDeductedByCashCoupons',
            currentAmortizationDeductedByCoupons: 'CurrentAmortizationDeductedByCoupons',
            currentAmortizationDeductedByPrepaidCard: 'CurrentAmortizationDeductedByPrepaidCard',
            currentAmortizationExpenditureAmount: 'CurrentAmortizationExpenditureAmount',
            currentAmortizationInvoiceDiscount: 'CurrentAmortizationInvoiceDiscount',
            currentAmortizationPretaxAmount: 'CurrentAmortizationPretaxAmount',
            currentAmortizationPretaxGrossAmount: 'CurrentAmortizationPretaxGrossAmount',
            currentAmortizationRoundDownDiscount: 'CurrentAmortizationRoundDownDiscount',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            expenditureAmount: 'ExpenditureAmount',
            invoiceDiscount: 'InvoiceDiscount',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            previouslyAmortizedDeductedByCashCoupons: 'PreviouslyAmortizedDeductedByCashCoupons',
            previouslyAmortizedDeductedByCoupons: 'PreviouslyAmortizedDeductedByCoupons',
            previouslyAmortizedDeductedByPrepaidCard: 'PreviouslyAmortizedDeductedByPrepaidCard',
            previouslyAmortizedExpenditureAmount: 'PreviouslyAmortizedExpenditureAmount',
            previouslyAmortizedInvoiceDiscount: 'PreviouslyAmortizedInvoiceDiscount',
            previouslyAmortizedPretaxAmount: 'PreviouslyAmortizedPretaxAmount',
            previouslyAmortizedPretaxGrossAmount: 'PreviouslyAmortizedPretaxGrossAmount',
            previouslyAmortizedRoundDownDiscount: 'PreviouslyAmortizedRoundDownDiscount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productDetailCode: 'ProductDetailCode',
            productName: 'ProductName',
            remainingAmortizationDeductedByCashCoupons: 'RemainingAmortizationDeductedByCashCoupons',
            remainingAmortizationDeductedByCoupons: 'RemainingAmortizationDeductedByCoupons',
            remainingAmortizationDeductedByPrepaidCard: 'RemainingAmortizationDeductedByPrepaidCard',
            remainingAmortizationExpenditureAmount: 'RemainingAmortizationExpenditureAmount',
            remainingAmortizationInvoiceDiscount: 'RemainingAmortizationInvoiceDiscount',
            remainingAmortizationPretaxAmount: 'RemainingAmortizationPretaxAmount',
            remainingAmortizationPretaxGrossAmount: 'RemainingAmortizationPretaxGrossAmount',
            remainingAmortizationRoundDownDiscount: 'RemainingAmortizationRoundDownDiscount',
            roundDownDiscount: 'RoundDownDiscount',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            amortizationPeriod: 'string',
            amortizationStatus: 'string',
            billAccountID: 'number',
            billAccountName: 'string',
            billOwnerID: 'number',
            billOwnerName: 'string',
            bizType: 'string',
            consumePeriod: 'string',
            currentAmortizationDeductedByCashCoupons: 'number',
            currentAmortizationDeductedByCoupons: 'number',
            currentAmortizationDeductedByPrepaidCard: 'number',
            currentAmortizationExpenditureAmount: 'number',
            currentAmortizationInvoiceDiscount: 'number',
            currentAmortizationPretaxAmount: 'number',
            currentAmortizationPretaxGrossAmount: 'number',
            currentAmortizationRoundDownDiscount: 'number',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            expenditureAmount: 'number',
            invoiceDiscount: 'number',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            previouslyAmortizedDeductedByCashCoupons: 'number',
            previouslyAmortizedDeductedByCoupons: 'number',
            previouslyAmortizedDeductedByPrepaidCard: 'number',
            previouslyAmortizedExpenditureAmount: 'number',
            previouslyAmortizedInvoiceDiscount: 'number',
            previouslyAmortizedPretaxAmount: 'number',
            previouslyAmortizedPretaxGrossAmount: 'number',
            previouslyAmortizedRoundDownDiscount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productDetailCode: 'string',
            productName: 'string',
            remainingAmortizationDeductedByCashCoupons: 'number',
            remainingAmortizationDeductedByCoupons: 'number',
            remainingAmortizationDeductedByPrepaidCard: 'number',
            remainingAmortizationExpenditureAmount: 'number',
            remainingAmortizationInvoiceDiscount: 'number',
            remainingAmortizationPretaxAmount: 'number',
            remainingAmortizationPretaxGrossAmount: 'number',
            remainingAmortizationRoundDownDiscount: 'number',
            roundDownDiscount: 'number',
            subscriptionType: 'string',
        };
    }
}
exports.DescribeProductAmortizedCostByConsumePeriodResponseBodyDataItems = DescribeProductAmortizedCostByConsumePeriodResponseBodyDataItems;
class DescribeProductAmortizedCostByConsumePeriodResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            items: { 'type': 'array', 'itemType': DescribeProductAmortizedCostByConsumePeriodResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeProductAmortizedCostByConsumePeriodResponseBodyData = DescribeProductAmortizedCostByConsumePeriodResponseBodyData;
class DescribeResourceCoverageDetailResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            capacityUnit: 'CapacityUnit',
            commodityCode: 'CommodityCode',
            commodityName: 'CommodityName',
            coveragePercentage: 'CoveragePercentage',
            currency: 'Currency',
            deductQuantity: 'DeductQuantity',
            endTime: 'EndTime',
            instanceId: 'InstanceId',
            instanceSpec: 'InstanceSpec',
            paymentAmount: 'PaymentAmount',
            productCode: 'ProductCode',
            productName: 'ProductName',
            region: 'Region',
            regionNo: 'RegionNo',
            startTime: 'StartTime',
            totalQuantity: 'TotalQuantity',
            userId: 'UserId',
            userName: 'UserName',
            zone: 'Zone',
            zoneName: 'ZoneName',
        };
    }
    static types() {
        return {
            capacityUnit: 'string',
            commodityCode: 'string',
            commodityName: 'string',
            coveragePercentage: 'number',
            currency: 'string',
            deductQuantity: 'number',
            endTime: 'string',
            instanceId: 'string',
            instanceSpec: 'string',
            paymentAmount: 'number',
            productCode: 'string',
            productName: 'string',
            region: 'string',
            regionNo: 'string',
            startTime: 'string',
            totalQuantity: 'number',
            userId: 'string',
            userName: 'string',
            zone: 'string',
            zoneName: 'string',
        };
    }
}
exports.DescribeResourceCoverageDetailResponseBodyDataItems = DescribeResourceCoverageDetailResponseBodyDataItems;
class DescribeResourceCoverageDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeResourceCoverageDetailResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeResourceCoverageDetailResponseBodyData = DescribeResourceCoverageDetailResponseBodyData;
class DescribeResourceCoverageTotalResponseBodyDataPeriodCoverage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coveragePercentage: 'CoveragePercentage',
            period: 'Period',
        };
    }
    static types() {
        return {
            coveragePercentage: 'number',
            period: 'string',
        };
    }
}
exports.DescribeResourceCoverageTotalResponseBodyDataPeriodCoverage = DescribeResourceCoverageTotalResponseBodyDataPeriodCoverage;
class DescribeResourceCoverageTotalResponseBodyDataTotalCoverage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            capacityUnit: 'CapacityUnit',
            coveragePercentage: 'CoveragePercentage',
            deductQuantity: 'DeductQuantity',
            totalQuantity: 'TotalQuantity',
        };
    }
    static types() {
        return {
            capacityUnit: 'string',
            coveragePercentage: 'number',
            deductQuantity: 'number',
            totalQuantity: 'number',
        };
    }
}
exports.DescribeResourceCoverageTotalResponseBodyDataTotalCoverage = DescribeResourceCoverageTotalResponseBodyDataTotalCoverage;
class DescribeResourceCoverageTotalResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            periodCoverage: 'PeriodCoverage',
            totalCoverage: 'TotalCoverage',
        };
    }
    static types() {
        return {
            periodCoverage: { 'type': 'array', 'itemType': DescribeResourceCoverageTotalResponseBodyDataPeriodCoverage },
            totalCoverage: DescribeResourceCoverageTotalResponseBodyDataTotalCoverage,
        };
    }
}
exports.DescribeResourceCoverageTotalResponseBodyData = DescribeResourceCoverageTotalResponseBodyData;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypePropertiesProperty extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            value: 'Value',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypePropertiesProperty = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypePropertiesProperty;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            property: 'Property',
        };
    }
    static types() {
        return {
            property: { 'type': 'array', 'itemType': DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypePropertiesProperty },
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeProperties = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeProperties;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurationsAvailableDuration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            unit: 'Unit',
            value: 'Value',
        };
    }
    static types() {
        return {
            name: 'string',
            unit: 'string',
            value: 'number',
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurationsAvailableDuration = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurationsAvailableDuration;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableDuration: 'AvailableDuration',
        };
    }
    static types() {
        return {
            availableDuration: { 'type': 'array', 'itemType': DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurationsAvailableDuration },
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurations = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurations;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecification extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableDurations: 'AvailableDurations',
            name: 'Name',
            value: 'Value',
        };
    }
    static types() {
        return {
            availableDurations: DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecificationAvailableDurations,
            name: 'string',
            value: 'string',
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecification = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecification;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecifications extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            specification: 'Specification',
        };
    }
    static types() {
        return {
            specification: { 'type': 'array', 'itemType': DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecificationsSpecification },
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecifications = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecifications;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageType extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            name: 'Name',
            properties: 'Properties',
            specifications: 'Specifications',
        };
    }
    static types() {
        return {
            code: 'string',
            name: 'string',
            properties: DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeProperties,
            specifications: DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageTypeSpecifications,
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageType = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageType;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            packageType: 'PackageType',
        };
    }
    static types() {
        return {
            packageType: { 'type': 'array', 'itemType': DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypesPackageType },
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypes = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypes;
class DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            packageTypes: 'PackageTypes',
            productCode: 'ProductCode',
            productType: 'ProductType',
        };
    }
    static types() {
        return {
            name: 'string',
            packageTypes: DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackagePackageTypes,
            productCode: 'string',
            productType: 'string',
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackage = DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackage;
class DescribeResourcePackageProductResponseBodyDataResourcePackages extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourcePackage: 'ResourcePackage',
        };
    }
    static types() {
        return {
            resourcePackage: { 'type': 'array', 'itemType': DescribeResourcePackageProductResponseBodyDataResourcePackagesResourcePackage },
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyDataResourcePackages = DescribeResourcePackageProductResponseBodyDataResourcePackages;
class DescribeResourcePackageProductResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourcePackages: 'ResourcePackages',
        };
    }
    static types() {
        return {
            resourcePackages: DescribeResourcePackageProductResponseBodyDataResourcePackages,
        };
    }
}
exports.DescribeResourcePackageProductResponseBodyData = DescribeResourcePackageProductResponseBodyData;
class DescribeResourceUsageDetailResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            capacityUnit: 'CapacityUnit',
            currency: 'Currency',
            deductQuantity: 'DeductQuantity',
            endTime: 'EndTime',
            imageType: 'ImageType',
            instanceSpec: 'InstanceSpec',
            postpaidCost: 'PostpaidCost',
            potentialSavedCost: 'PotentialSavedCost',
            quantity: 'Quantity',
            region: 'Region',
            regionNo: 'RegionNo',
            reservationCost: 'ReservationCost',
            resourceInstanceId: 'ResourceInstanceId',
            savedCost: 'SavedCost',
            startTime: 'StartTime',
            status: 'Status',
            statusName: 'StatusName',
            totalQuantity: 'TotalQuantity',
            usagePercentage: 'UsagePercentage',
            userId: 'UserId',
            userName: 'UserName',
            zone: 'Zone',
            zoneName: 'ZoneName',
        };
    }
    static types() {
        return {
            capacityUnit: 'string',
            currency: 'string',
            deductQuantity: 'number',
            endTime: 'string',
            imageType: 'string',
            instanceSpec: 'string',
            postpaidCost: 'string',
            potentialSavedCost: 'string',
            quantity: 'number',
            region: 'string',
            regionNo: 'string',
            reservationCost: 'string',
            resourceInstanceId: 'string',
            savedCost: 'string',
            startTime: 'string',
            status: 'string',
            statusName: 'string',
            totalQuantity: 'number',
            usagePercentage: 'number',
            userId: 'string',
            userName: 'string',
            zone: 'string',
            zoneName: 'string',
        };
    }
}
exports.DescribeResourceUsageDetailResponseBodyDataItems = DescribeResourceUsageDetailResponseBodyDataItems;
class DescribeResourceUsageDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeResourceUsageDetailResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeResourceUsageDetailResponseBodyData = DescribeResourceUsageDetailResponseBodyData;
class DescribeResourceUsageTotalResponseBodyDataPeriodCoverage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            period: 'Period',
            usagePercentage: 'UsagePercentage',
        };
    }
    static types() {
        return {
            period: 'string',
            usagePercentage: 'number',
        };
    }
}
exports.DescribeResourceUsageTotalResponseBodyDataPeriodCoverage = DescribeResourceUsageTotalResponseBodyDataPeriodCoverage;
class DescribeResourceUsageTotalResponseBodyDataTotalUsage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            postpaidCost: 'PostpaidCost',
            potentialSavedCost: 'PotentialSavedCost',
            reservationCost: 'ReservationCost',
            savedCost: 'SavedCost',
            usagePercentage: 'UsagePercentage',
        };
    }
    static types() {
        return {
            postpaidCost: 'number',
            potentialSavedCost: 'number',
            reservationCost: 'number',
            savedCost: 'number',
            usagePercentage: 'number',
        };
    }
}
exports.DescribeResourceUsageTotalResponseBodyDataTotalUsage = DescribeResourceUsageTotalResponseBodyDataTotalUsage;
class DescribeResourceUsageTotalResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            periodCoverage: 'PeriodCoverage',
            totalUsage: 'TotalUsage',
        };
    }
    static types() {
        return {
            periodCoverage: { 'type': 'array', 'itemType': DescribeResourceUsageTotalResponseBodyDataPeriodCoverage },
            totalUsage: DescribeResourceUsageTotalResponseBodyDataTotalUsage,
        };
    }
}
exports.DescribeResourceUsageTotalResponseBodyData = DescribeResourceUsageTotalResponseBodyData;
class DescribeSavingsPlansCoverageDetailResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coveragePercentage: 'CoveragePercentage',
            currency: 'Currency',
            deductAmount: 'DeductAmount',
            endPeriod: 'EndPeriod',
            instanceId: 'InstanceId',
            instanceSpec: 'InstanceSpec',
            postpaidCost: 'PostpaidCost',
            region: 'Region',
            startPeriod: 'StartPeriod',
            totalAmount: 'TotalAmount',
            userId: 'UserId',
            userName: 'UserName',
        };
    }
    static types() {
        return {
            coveragePercentage: 'number',
            currency: 'string',
            deductAmount: 'number',
            endPeriod: 'string',
            instanceId: 'string',
            instanceSpec: 'string',
            postpaidCost: 'number',
            region: 'string',
            startPeriod: 'string',
            totalAmount: 'number',
            userId: 'number',
            userName: 'string',
        };
    }
}
exports.DescribeSavingsPlansCoverageDetailResponseBodyDataItems = DescribeSavingsPlansCoverageDetailResponseBodyDataItems;
class DescribeSavingsPlansCoverageDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeSavingsPlansCoverageDetailResponseBodyDataItems },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeSavingsPlansCoverageDetailResponseBodyData = DescribeSavingsPlansCoverageDetailResponseBodyData;
class DescribeSavingsPlansCoverageTotalResponseBodyDataPeriodCoverage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            percentage: 'Percentage',
            period: 'Period',
        };
    }
    static types() {
        return {
            percentage: 'number',
            period: 'string',
        };
    }
}
exports.DescribeSavingsPlansCoverageTotalResponseBodyDataPeriodCoverage = DescribeSavingsPlansCoverageTotalResponseBodyDataPeriodCoverage;
class DescribeSavingsPlansCoverageTotalResponseBodyDataTotalCoverage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coveragePercentage: 'CoveragePercentage',
            deductAmount: 'DeductAmount',
        };
    }
    static types() {
        return {
            coveragePercentage: 'number',
            deductAmount: 'number',
        };
    }
}
exports.DescribeSavingsPlansCoverageTotalResponseBodyDataTotalCoverage = DescribeSavingsPlansCoverageTotalResponseBodyDataTotalCoverage;
class DescribeSavingsPlansCoverageTotalResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            periodCoverage: 'PeriodCoverage',
            totalCoverage: 'TotalCoverage',
        };
    }
    static types() {
        return {
            periodCoverage: { 'type': 'array', 'itemType': DescribeSavingsPlansCoverageTotalResponseBodyDataPeriodCoverage },
            totalCoverage: DescribeSavingsPlansCoverageTotalResponseBodyDataTotalCoverage,
        };
    }
}
exports.DescribeSavingsPlansCoverageTotalResponseBodyData = DescribeSavingsPlansCoverageTotalResponseBodyData;
class DescribeSavingsPlansUsageDetailResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currency: 'Currency',
            deductValue: 'DeductValue',
            endPeriod: 'EndPeriod',
            instanceId: 'InstanceId',
            poolValue: 'PoolValue',
            postpaidCost: 'PostpaidCost',
            savedCost: 'SavedCost',
            startPeriod: 'StartPeriod',
            status: 'Status',
            type: 'Type',
            usagePercentage: 'UsagePercentage',
            userId: 'UserId',
            userName: 'UserName',
        };
    }
    static types() {
        return {
            currency: 'string',
            deductValue: 'number',
            endPeriod: 'string',
            instanceId: 'string',
            poolValue: 'number',
            postpaidCost: 'number',
            savedCost: 'number',
            startPeriod: 'string',
            status: 'string',
            type: 'string',
            usagePercentage: 'number',
            userId: 'number',
            userName: 'string',
        };
    }
}
exports.DescribeSavingsPlansUsageDetailResponseBodyDataItems = DescribeSavingsPlansUsageDetailResponseBodyDataItems;
class DescribeSavingsPlansUsageDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeSavingsPlansUsageDetailResponseBodyDataItems },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeSavingsPlansUsageDetailResponseBodyData = DescribeSavingsPlansUsageDetailResponseBodyData;
class DescribeSavingsPlansUsageTotalResponseBodyDataPeriodCoverage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            percentage: 'Percentage',
            period: 'Period',
        };
    }
    static types() {
        return {
            percentage: 'number',
            period: 'string',
        };
    }
}
exports.DescribeSavingsPlansUsageTotalResponseBodyDataPeriodCoverage = DescribeSavingsPlansUsageTotalResponseBodyDataPeriodCoverage;
class DescribeSavingsPlansUsageTotalResponseBodyDataTotalUsage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            poolValue: 'PoolValue',
            postpaidCost: 'PostpaidCost',
            savedCost: 'SavedCost',
            usagePercentage: 'UsagePercentage',
        };
    }
    static types() {
        return {
            poolValue: 'number',
            postpaidCost: 'number',
            savedCost: 'number',
            usagePercentage: 'number',
        };
    }
}
exports.DescribeSavingsPlansUsageTotalResponseBodyDataTotalUsage = DescribeSavingsPlansUsageTotalResponseBodyDataTotalUsage;
class DescribeSavingsPlansUsageTotalResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            periodCoverage: 'PeriodCoverage',
            totalUsage: 'TotalUsage',
        };
    }
    static types() {
        return {
            periodCoverage: { 'type': 'array', 'itemType': DescribeSavingsPlansUsageTotalResponseBodyDataPeriodCoverage },
            totalUsage: DescribeSavingsPlansUsageTotalResponseBodyDataTotalUsage,
        };
    }
}
exports.DescribeSavingsPlansUsageTotalResponseBodyData = DescribeSavingsPlansUsageTotalResponseBodyData;
class DescribeSplitItemBillRequestTagFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValues: 'TagValues',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValues: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeSplitItemBillRequestTagFilter = DescribeSplitItemBillRequestTagFilter;
class DescribeSplitItemBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billingDate: 'BillingDate',
            billingItem: 'BillingItem',
            billingItemCode: 'BillingItemCode',
            billingType: 'BillingType',
            bizType: 'BizType',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            costUnit: 'CostUnit',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            deductedByResourcePackage: 'DeductedByResourcePackage',
            instanceConfig: 'InstanceConfig',
            instanceID: 'InstanceID',
            instanceSpec: 'InstanceSpec',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            itemName: 'ItemName',
            listPrice: 'ListPrice',
            listPriceUnit: 'ListPriceUnit',
            nickName: 'NickName',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            region: 'Region',
            resourceGroup: 'ResourceGroup',
            servicePeriod: 'ServicePeriod',
            servicePeriodUnit: 'ServicePeriodUnit',
            splitAccountID: 'SplitAccountID',
            splitAccountName: 'SplitAccountName',
            splitBillingCycle: 'SplitBillingCycle',
            splitBillingDate: 'SplitBillingDate',
            splitCommodityCode: 'SplitCommodityCode',
            splitItemID: 'SplitItemID',
            splitItemName: 'SplitItemName',
            splitProductDetail: 'SplitProductDetail',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            usage: 'Usage',
            usageUnit: 'UsageUnit',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            billAccountID: 'string',
            billAccountName: 'string',
            billingDate: 'string',
            billingItem: 'string',
            billingItemCode: 'string',
            billingType: 'string',
            bizType: 'string',
            cashAmount: 'number',
            commodityCode: 'string',
            costUnit: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            deductedByResourcePackage: 'string',
            instanceConfig: 'string',
            instanceID: 'string',
            instanceSpec: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            item: 'string',
            itemName: 'string',
            listPrice: 'string',
            listPriceUnit: 'string',
            nickName: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            region: 'string',
            resourceGroup: 'string',
            servicePeriod: 'string',
            servicePeriodUnit: 'string',
            splitAccountID: 'string',
            splitAccountName: 'string',
            splitBillingCycle: 'string',
            splitBillingDate: 'string',
            splitCommodityCode: 'string',
            splitItemID: 'string',
            splitItemName: 'string',
            splitProductDetail: 'string',
            subscriptionType: 'string',
            tag: 'string',
            usage: 'string',
            usageUnit: 'string',
            zone: 'string',
        };
    }
}
exports.DescribeSplitItemBillResponseBodyDataItems = DescribeSplitItemBillResponseBodyDataItems;
class DescribeSplitItemBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: { 'type': 'array', 'itemType': DescribeSplitItemBillResponseBodyDataItems },
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeSplitItemBillResponseBodyData = DescribeSplitItemBillResponseBodyData;
class EnableBillGenerationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            boolean: 'Boolean',
        };
    }
    static types() {
        return {
            boolean: 'boolean',
        };
    }
}
exports.EnableBillGenerationResponseBodyData = EnableBillGenerationResponseBodyData;
class GetAccountRelationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            childUserId: 'ChildUserId',
            endTime: 'EndTime',
            gmtModified: 'GmtModified',
            id: 'Id',
            parentUserId: 'ParentUserId',
            startTime: 'StartTime',
            status: 'Status',
            type: 'Type',
        };
    }
    static types() {
        return {
            childUserId: 'number',
            endTime: 'number',
            gmtModified: 'number',
            id: 'number',
            parentUserId: 'number',
            startTime: 'number',
            status: 'string',
            type: 'string',
        };
    }
}
exports.GetAccountRelationResponseBodyData = GetAccountRelationResponseBodyData;
class GetCustomerAccountInfoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'AccountType',
            creditLimitStatus: 'CreditLimitStatus',
            hostingStatus: 'HostingStatus',
            isCertified: 'IsCertified',
            loginEmail: 'LoginEmail',
            mpk: 'Mpk',
        };
    }
    static types() {
        return {
            accountType: 'string',
            creditLimitStatus: 'string',
            hostingStatus: 'string',
            isCertified: 'boolean',
            loginEmail: 'string',
            mpk: 'number',
        };
    }
}
exports.GetCustomerAccountInfoResponseBodyData = GetCustomerAccountInfoResponseBodyData;
class GetCustomerListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            uidList: 'UidList',
        };
    }
    static types() {
        return {
            uidList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetCustomerListResponseBodyData = GetCustomerListResponseBodyData;
class GetOrderDetailResponseBodyDataOrderListOrder extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            afterTaxAmount: 'AfterTaxAmount',
            commodityCode: 'CommodityCode',
            config: 'Config',
            createTime: 'CreateTime',
            currency: 'Currency',
            instanceIDs: 'InstanceIDs',
            operator: 'Operator',
            orderId: 'OrderId',
            orderSubType: 'OrderSubType',
            orderType: 'OrderType',
            originalConfig: 'OriginalConfig',
            paymentCurrency: 'PaymentCurrency',
            paymentStatus: 'PaymentStatus',
            paymentTime: 'PaymentTime',
            pretaxAmount: 'PretaxAmount',
            pretaxAmountLocal: 'PretaxAmountLocal',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productType: 'ProductType',
            quantity: 'Quantity',
            region: 'Region',
            relatedOrderId: 'RelatedOrderId',
            subOrderId: 'SubOrderId',
            subscriptionType: 'SubscriptionType',
            tax: 'Tax',
            usageEndTime: 'UsageEndTime',
            usageStartTime: 'UsageStartTime',
        };
    }
    static types() {
        return {
            afterTaxAmount: 'string',
            commodityCode: 'string',
            config: 'string',
            createTime: 'string',
            currency: 'string',
            instanceIDs: 'string',
            operator: 'string',
            orderId: 'string',
            orderSubType: 'string',
            orderType: 'string',
            originalConfig: 'string',
            paymentCurrency: 'string',
            paymentStatus: 'string',
            paymentTime: 'string',
            pretaxAmount: 'string',
            pretaxAmountLocal: 'string',
            pretaxGrossAmount: 'string',
            productCode: 'string',
            productType: 'string',
            quantity: 'string',
            region: 'string',
            relatedOrderId: 'string',
            subOrderId: 'string',
            subscriptionType: 'string',
            tax: 'string',
            usageEndTime: 'string',
            usageStartTime: 'string',
        };
    }
}
exports.GetOrderDetailResponseBodyDataOrderListOrder = GetOrderDetailResponseBodyDataOrderListOrder;
class GetOrderDetailResponseBodyDataOrderList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            order: 'Order',
        };
    }
    static types() {
        return {
            order: { 'type': 'array', 'itemType': GetOrderDetailResponseBodyDataOrderListOrder },
        };
    }
}
exports.GetOrderDetailResponseBodyDataOrderList = GetOrderDetailResponseBodyDataOrderList;
class GetOrderDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostName: 'HostName',
            orderList: 'OrderList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            hostName: 'string',
            orderList: GetOrderDetailResponseBodyDataOrderList,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.GetOrderDetailResponseBodyData = GetOrderDetailResponseBodyData;
class GetPayAsYouGoPriceRequestModuleList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'Config',
            moduleCode: 'ModuleCode',
            priceType: 'PriceType',
        };
    }
    static types() {
        return {
            config: 'string',
            moduleCode: 'string',
            priceType: 'string',
        };
    }
}
exports.GetPayAsYouGoPriceRequestModuleList = GetPayAsYouGoPriceRequestModuleList;
class GetPayAsYouGoPriceResponseBodyDataModuleDetailsModuleDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            costAfterDiscount: 'CostAfterDiscount',
            invoiceDiscount: 'InvoiceDiscount',
            moduleCode: 'ModuleCode',
            originalCost: 'OriginalCost',
            unitPrice: 'UnitPrice',
        };
    }
    static types() {
        return {
            costAfterDiscount: 'number',
            invoiceDiscount: 'number',
            moduleCode: 'string',
            originalCost: 'number',
            unitPrice: 'number',
        };
    }
}
exports.GetPayAsYouGoPriceResponseBodyDataModuleDetailsModuleDetail = GetPayAsYouGoPriceResponseBodyDataModuleDetailsModuleDetail;
class GetPayAsYouGoPriceResponseBodyDataModuleDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            moduleDetail: 'ModuleDetail',
        };
    }
    static types() {
        return {
            moduleDetail: { 'type': 'array', 'itemType': GetPayAsYouGoPriceResponseBodyDataModuleDetailsModuleDetail },
        };
    }
}
exports.GetPayAsYouGoPriceResponseBodyDataModuleDetails = GetPayAsYouGoPriceResponseBodyDataModuleDetails;
class GetPayAsYouGoPriceResponseBodyDataPromotionDetailsPromotionDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            promotionDesc: 'PromotionDesc',
            promotionId: 'PromotionId',
            promotionName: 'PromotionName',
        };
    }
    static types() {
        return {
            promotionDesc: 'string',
            promotionId: 'number',
            promotionName: 'string',
        };
    }
}
exports.GetPayAsYouGoPriceResponseBodyDataPromotionDetailsPromotionDetail = GetPayAsYouGoPriceResponseBodyDataPromotionDetailsPromotionDetail;
class GetPayAsYouGoPriceResponseBodyDataPromotionDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            promotionDetail: 'PromotionDetail',
        };
    }
    static types() {
        return {
            promotionDetail: { 'type': 'array', 'itemType': GetPayAsYouGoPriceResponseBodyDataPromotionDetailsPromotionDetail },
        };
    }
}
exports.GetPayAsYouGoPriceResponseBodyDataPromotionDetails = GetPayAsYouGoPriceResponseBodyDataPromotionDetails;
class GetPayAsYouGoPriceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currency: 'Currency',
            moduleDetails: 'ModuleDetails',
            promotionDetails: 'PromotionDetails',
        };
    }
    static types() {
        return {
            currency: 'string',
            moduleDetails: GetPayAsYouGoPriceResponseBodyDataModuleDetails,
            promotionDetails: GetPayAsYouGoPriceResponseBodyDataPromotionDetails,
        };
    }
}
exports.GetPayAsYouGoPriceResponseBodyData = GetPayAsYouGoPriceResponseBodyData;
class GetResourcePackagePriceResponseBodyDataPromotionsPromotion extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'Id',
            name: 'Name',
        };
    }
    static types() {
        return {
            id: 'number',
            name: 'string',
        };
    }
}
exports.GetResourcePackagePriceResponseBodyDataPromotionsPromotion = GetResourcePackagePriceResponseBodyDataPromotionsPromotion;
class GetResourcePackagePriceResponseBodyDataPromotions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            promotion: 'Promotion',
        };
    }
    static types() {
        return {
            promotion: { 'type': 'array', 'itemType': GetResourcePackagePriceResponseBodyDataPromotionsPromotion },
        };
    }
}
exports.GetResourcePackagePriceResponseBodyDataPromotions = GetResourcePackagePriceResponseBodyDataPromotions;
class GetResourcePackagePriceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currency: 'Currency',
            discountPrice: 'DiscountPrice',
            originalPrice: 'OriginalPrice',
            promotions: 'Promotions',
            tradePrice: 'TradePrice',
        };
    }
    static types() {
        return {
            currency: 'string',
            discountPrice: 'number',
            originalPrice: 'number',
            promotions: GetResourcePackagePriceResponseBodyDataPromotions,
            tradePrice: 'number',
        };
    }
}
exports.GetResourcePackagePriceResponseBodyData = GetResourcePackagePriceResponseBodyData;
class GetSubscriptionPriceRequestModuleList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'Config',
            moduleCode: 'ModuleCode',
            moduleStatus: 'ModuleStatus',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            config: 'string',
            moduleCode: 'string',
            moduleStatus: 'number',
            tag: 'string',
        };
    }
}
exports.GetSubscriptionPriceRequestModuleList = GetSubscriptionPriceRequestModuleList;
class GetSubscriptionPriceResponseBodyDataModuleDetailsModuleDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            costAfterDiscount: 'CostAfterDiscount',
            invoiceDiscount: 'InvoiceDiscount',
            moduleCode: 'ModuleCode',
            originalCost: 'OriginalCost',
            unitPrice: 'UnitPrice',
        };
    }
    static types() {
        return {
            costAfterDiscount: 'number',
            invoiceDiscount: 'number',
            moduleCode: 'string',
            originalCost: 'number',
            unitPrice: 'number',
        };
    }
}
exports.GetSubscriptionPriceResponseBodyDataModuleDetailsModuleDetail = GetSubscriptionPriceResponseBodyDataModuleDetailsModuleDetail;
class GetSubscriptionPriceResponseBodyDataModuleDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            moduleDetail: 'ModuleDetail',
        };
    }
    static types() {
        return {
            moduleDetail: { 'type': 'array', 'itemType': GetSubscriptionPriceResponseBodyDataModuleDetailsModuleDetail },
        };
    }
}
exports.GetSubscriptionPriceResponseBodyDataModuleDetails = GetSubscriptionPriceResponseBodyDataModuleDetails;
class GetSubscriptionPriceResponseBodyDataPromotionDetailsPromotionDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            promotionDesc: 'PromotionDesc',
            promotionId: 'PromotionId',
            promotionName: 'PromotionName',
        };
    }
    static types() {
        return {
            promotionDesc: 'string',
            promotionId: 'number',
            promotionName: 'string',
        };
    }
}
exports.GetSubscriptionPriceResponseBodyDataPromotionDetailsPromotionDetail = GetSubscriptionPriceResponseBodyDataPromotionDetailsPromotionDetail;
class GetSubscriptionPriceResponseBodyDataPromotionDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            promotionDetail: 'PromotionDetail',
        };
    }
    static types() {
        return {
            promotionDetail: { 'type': 'array', 'itemType': GetSubscriptionPriceResponseBodyDataPromotionDetailsPromotionDetail },
        };
    }
}
exports.GetSubscriptionPriceResponseBodyDataPromotionDetails = GetSubscriptionPriceResponseBodyDataPromotionDetails;
class GetSubscriptionPriceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currency: 'Currency',
            discountPrice: 'DiscountPrice',
            moduleDetails: 'ModuleDetails',
            originalPrice: 'OriginalPrice',
            promotionDetails: 'PromotionDetails',
            quantity: 'Quantity',
            tradePrice: 'TradePrice',
        };
    }
    static types() {
        return {
            currency: 'string',
            discountPrice: 'number',
            moduleDetails: GetSubscriptionPriceResponseBodyDataModuleDetails,
            originalPrice: 'number',
            promotionDetails: GetSubscriptionPriceResponseBodyDataPromotionDetails,
            quantity: 'number',
            tradePrice: 'number',
        };
    }
}
exports.GetSubscriptionPriceResponseBodyData = GetSubscriptionPriceResponseBodyData;
class InquiryPriceRefundInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currency: 'Currency',
            hostId: 'HostId',
            instanceId: 'InstanceId',
            refundAmount: 'RefundAmount',
        };
    }
    static types() {
        return {
            currency: 'string',
            hostId: 'string',
            instanceId: 'string',
            refundAmount: 'number',
        };
    }
}
exports.InquiryPriceRefundInstanceResponseBodyData = InquiryPriceRefundInstanceResponseBodyData;
class ModifyAccountRelationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
        };
    }
    static types() {
        return {
            hostId: 'string',
        };
    }
}
exports.ModifyAccountRelationResponseBodyData = ModifyAccountRelationResponseBodyData;
class ModifyCostUnitRequestUnitEntityList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            newUnitName: 'NewUnitName',
            ownerUid: 'OwnerUid',
            unitId: 'UnitId',
        };
    }
    static types() {
        return {
            newUnitName: 'string',
            ownerUid: 'number',
            unitId: 'number',
        };
    }
}
exports.ModifyCostUnitRequestUnitEntityList = ModifyCostUnitRequestUnitEntityList;
class ModifyCostUnitResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isSuccess: 'IsSuccess',
            ownerUid: 'OwnerUid',
            unitId: 'UnitId',
        };
    }
    static types() {
        return {
            isSuccess: 'boolean',
            ownerUid: 'number',
            unitId: 'number',
        };
    }
}
exports.ModifyCostUnitResponseBodyData = ModifyCostUnitResponseBodyData;
class ModifyInstanceRequestParameter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            value: 'Value',
        };
    }
    static types() {
        return {
            code: 'string',
            value: 'string',
        };
    }
}
exports.ModifyInstanceRequestParameter = ModifyInstanceRequestParameter;
class ModifyInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            hostId: 'string',
            orderId: 'string',
        };
    }
}
exports.ModifyInstanceResponseBodyData = ModifyInstanceResponseBodyData;
class QueryAccountBalanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableAmount: 'AvailableAmount',
            availableCashAmount: 'AvailableCashAmount',
            creditAmount: 'CreditAmount',
            currency: 'Currency',
            mybankCreditAmount: 'MybankCreditAmount',
        };
    }
    static types() {
        return {
            availableAmount: 'string',
            availableCashAmount: 'string',
            creditAmount: 'string',
            currency: 'string',
            mybankCreditAmount: 'string',
        };
    }
}
exports.QueryAccountBalanceResponseBodyData = QueryAccountBalanceResponseBodyData;
class QueryAccountBillResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            billingDate: 'BillingDate',
            bizType: 'BizType',
            cashAmount: 'CashAmount',
            costUnit: 'CostUnit',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            invoiceDiscount: 'InvoiceDiscount',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            ownerName: 'OwnerName',
            paymentAmount: 'PaymentAmount',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productName: 'ProductName',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            billAccountID: 'string',
            billAccountName: 'string',
            billingDate: 'string',
            bizType: 'string',
            cashAmount: 'number',
            costUnit: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            invoiceDiscount: 'number',
            outstandingAmount: 'number',
            ownerID: 'string',
            ownerName: 'string',
            paymentAmount: 'number',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productName: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryAccountBillResponseBodyDataItemsItem = QueryAccountBillResponseBodyDataItemsItem;
class QueryAccountBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QueryAccountBillResponseBodyDataItemsItem },
        };
    }
}
exports.QueryAccountBillResponseBodyDataItems = QueryAccountBillResponseBodyDataItems;
class QueryAccountBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: QueryAccountBillResponseBodyDataItems,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryAccountBillResponseBodyData = QueryAccountBillResponseBodyData;
class QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsListAccountTransactionsList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'Amount',
            balance: 'Balance',
            billingCycle: 'BillingCycle',
            fundType: 'FundType',
            recordID: 'RecordID',
            remarks: 'Remarks',
            transactionAccount: 'TransactionAccount',
            transactionChannel: 'TransactionChannel',
            transactionChannelSN: 'TransactionChannelSN',
            transactionFlow: 'TransactionFlow',
            transactionNumber: 'TransactionNumber',
            transactionTime: 'TransactionTime',
            transactionType: 'TransactionType',
        };
    }
    static types() {
        return {
            amount: 'string',
            balance: 'string',
            billingCycle: 'string',
            fundType: 'string',
            recordID: 'string',
            remarks: 'string',
            transactionAccount: 'string',
            transactionChannel: 'string',
            transactionChannelSN: 'string',
            transactionFlow: 'string',
            transactionNumber: 'string',
            transactionTime: 'string',
            transactionType: 'string',
        };
    }
}
exports.QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsListAccountTransactionsList = QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsListAccountTransactionsList;
class QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountTransactionsList: 'AccountTransactionsList',
        };
    }
    static types() {
        return {
            accountTransactionsList: { 'type': 'array', 'itemType': QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsListAccountTransactionsList },
        };
    }
}
exports.QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsList = QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsList;
class QueryAccountTransactionDetailsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            accountTransactionsList: 'AccountTransactionsList',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountName: 'string',
            accountTransactionsList: QueryAccountTransactionDetailsResponseBodyDataAccountTransactionsList,
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.QueryAccountTransactionDetailsResponseBodyData = QueryAccountTransactionDetailsResponseBodyData;
class QueryAccountTransactionsResponseBodyDataAccountTransactionsListAccountTransactionsList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'Amount',
            balance: 'Balance',
            billingCycle: 'BillingCycle',
            fundType: 'FundType',
            recordID: 'RecordID',
            remarks: 'Remarks',
            transactionAccount: 'TransactionAccount',
            transactionChannel: 'TransactionChannel',
            transactionChannelSN: 'TransactionChannelSN',
            transactionFlow: 'TransactionFlow',
            transactionNumber: 'TransactionNumber',
            transactionTime: 'TransactionTime',
            transactionType: 'TransactionType',
        };
    }
    static types() {
        return {
            amount: 'string',
            balance: 'string',
            billingCycle: 'string',
            fundType: 'string',
            recordID: 'string',
            remarks: 'string',
            transactionAccount: 'string',
            transactionChannel: 'string',
            transactionChannelSN: 'string',
            transactionFlow: 'string',
            transactionNumber: 'string',
            transactionTime: 'string',
            transactionType: 'string',
        };
    }
}
exports.QueryAccountTransactionsResponseBodyDataAccountTransactionsListAccountTransactionsList = QueryAccountTransactionsResponseBodyDataAccountTransactionsListAccountTransactionsList;
class QueryAccountTransactionsResponseBodyDataAccountTransactionsList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountTransactionsList: 'AccountTransactionsList',
        };
    }
    static types() {
        return {
            accountTransactionsList: { 'type': 'array', 'itemType': QueryAccountTransactionsResponseBodyDataAccountTransactionsListAccountTransactionsList },
        };
    }
}
exports.QueryAccountTransactionsResponseBodyDataAccountTransactionsList = QueryAccountTransactionsResponseBodyDataAccountTransactionsList;
class QueryAccountTransactionsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            accountTransactionsList: 'AccountTransactionsList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountName: 'string',
            accountTransactionsList: QueryAccountTransactionsResponseBodyDataAccountTransactionsList,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryAccountTransactionsResponseBodyData = QueryAccountTransactionsResponseBodyData;
class QueryAvailableInstancesResponseBodyDataInstanceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            endTime: 'EndTime',
            expectedReleaseTime: 'ExpectedReleaseTime',
            instanceID: 'InstanceID',
            ownerId: 'OwnerId',
            productCode: 'ProductCode',
            productType: 'ProductType',
            region: 'Region',
            releaseTime: 'ReleaseTime',
            renewStatus: 'RenewStatus',
            renewalDuration: 'RenewalDuration',
            renewalDurationUnit: 'RenewalDurationUnit',
            seller: 'Seller',
            sellerId: 'SellerId',
            status: 'Status',
            stopTime: 'StopTime',
            subStatus: 'SubStatus',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            createTime: 'string',
            endTime: 'string',
            expectedReleaseTime: 'string',
            instanceID: 'string',
            ownerId: 'number',
            productCode: 'string',
            productType: 'string',
            region: 'string',
            releaseTime: 'string',
            renewStatus: 'string',
            renewalDuration: 'number',
            renewalDurationUnit: 'string',
            seller: 'string',
            sellerId: 'number',
            status: 'string',
            stopTime: 'string',
            subStatus: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryAvailableInstancesResponseBodyDataInstanceList = QueryAvailableInstancesResponseBodyDataInstanceList;
class QueryAvailableInstancesResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceList: 'InstanceList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            instanceList: { 'type': 'array', 'itemType': QueryAvailableInstancesResponseBodyDataInstanceList },
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryAvailableInstancesResponseBodyData = QueryAvailableInstancesResponseBodyData;
class QueryBillResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            afterTaxAmount: 'AfterTaxAmount',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            paymentCurrency: 'PaymentCurrency',
            paymentTime: 'PaymentTime',
            paymentTransactionID: 'PaymentTransactionID',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxAmountLocal: 'PretaxAmountLocal',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            recordID: 'RecordID',
            roundDownDiscount: 'RoundDownDiscount',
            status: 'Status',
            subOrderId: 'SubOrderId',
            subscriptionType: 'SubscriptionType',
            tax: 'Tax',
            usageEndTime: 'UsageEndTime',
            usageStartTime: 'UsageStartTime',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            afterTaxAmount: 'number',
            cashAmount: 'number',
            commodityCode: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            invoiceDiscount: 'number',
            item: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            paymentCurrency: 'string',
            paymentTime: 'string',
            paymentTransactionID: 'string',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxAmountLocal: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            recordID: 'string',
            roundDownDiscount: 'string',
            status: 'string',
            subOrderId: 'string',
            subscriptionType: 'string',
            tax: 'number',
            usageEndTime: 'string',
            usageStartTime: 'string',
        };
    }
}
exports.QueryBillResponseBodyDataItemsItem = QueryBillResponseBodyDataItemsItem;
class QueryBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QueryBillResponseBodyDataItemsItem },
        };
    }
}
exports.QueryBillResponseBodyDataItems = QueryBillResponseBodyDataItems;
class QueryBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: QueryBillResponseBodyDataItems,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryBillResponseBodyData = QueryBillResponseBodyData;
class QueryBillOverviewResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            afterTaxAmount: 'AfterTaxAmount',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            bizType: 'BizType',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            paymentCurrency: 'PaymentCurrency',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxAmountLocal: 'PretaxAmountLocal',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            roundDownDiscount: 'RoundDownDiscount',
            subscriptionType: 'SubscriptionType',
            tax: 'Tax',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            afterTaxAmount: 'number',
            billAccountID: 'string',
            billAccountName: 'string',
            bizType: 'string',
            cashAmount: 'number',
            commodityCode: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            invoiceDiscount: 'number',
            item: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            paymentCurrency: 'string',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxAmountLocal: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            roundDownDiscount: 'string',
            subscriptionType: 'string',
            tax: 'number',
        };
    }
}
exports.QueryBillOverviewResponseBodyDataItemsItem = QueryBillOverviewResponseBodyDataItemsItem;
class QueryBillOverviewResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QueryBillOverviewResponseBodyDataItemsItem },
        };
    }
}
exports.QueryBillOverviewResponseBodyDataItems = QueryBillOverviewResponseBodyDataItems;
class QueryBillOverviewResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: QueryBillOverviewResponseBodyDataItems,
        };
    }
}
exports.QueryBillOverviewResponseBodyData = QueryBillOverviewResponseBodyData;
class QueryBillToOSSSubscriptionResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketOwnerId: 'BucketOwnerId',
            bucketPath: 'BucketPath',
            rowLimitPerFile: 'RowLimitPerFile',
            subscribeBucket: 'SubscribeBucket',
            subscribeLanguage: 'SubscribeLanguage',
            subscribeTime: 'SubscribeTime',
            subscribeType: 'SubscribeType',
        };
    }
    static types() {
        return {
            bucketOwnerId: 'number',
            bucketPath: 'string',
            rowLimitPerFile: 'number',
            subscribeBucket: 'string',
            subscribeLanguage: 'string',
            subscribeTime: 'string',
            subscribeType: 'string',
        };
    }
}
exports.QueryBillToOSSSubscriptionResponseBodyDataItemsItem = QueryBillToOSSSubscriptionResponseBodyDataItemsItem;
class QueryBillToOSSSubscriptionResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QueryBillToOSSSubscriptionResponseBodyDataItemsItem },
        };
    }
}
exports.QueryBillToOSSSubscriptionResponseBodyDataItems = QueryBillToOSSSubscriptionResponseBodyDataItems;
class QueryBillToOSSSubscriptionResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            items: 'Items',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            items: QueryBillToOSSSubscriptionResponseBodyDataItems,
        };
    }
}
exports.QueryBillToOSSSubscriptionResponseBodyData = QueryBillToOSSSubscriptionResponseBodyData;
class QueryCashCouponsResponseBodyDataCashCoupon extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicableProducts: 'ApplicableProducts',
            applicableScenarios: 'ApplicableScenarios',
            balance: 'Balance',
            cashCouponId: 'CashCouponId',
            cashCouponNo: 'CashCouponNo',
            effectiveTime: 'EffectiveTime',
            expiryTime: 'ExpiryTime',
            grantedTime: 'GrantedTime',
            nominalValue: 'NominalValue',
            status: 'Status',
        };
    }
    static types() {
        return {
            applicableProducts: 'string',
            applicableScenarios: 'string',
            balance: 'string',
            cashCouponId: 'number',
            cashCouponNo: 'string',
            effectiveTime: 'string',
            expiryTime: 'string',
            grantedTime: 'string',
            nominalValue: 'string',
            status: 'string',
        };
    }
}
exports.QueryCashCouponsResponseBodyDataCashCoupon = QueryCashCouponsResponseBodyDataCashCoupon;
class QueryCashCouponsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cashCoupon: 'CashCoupon',
        };
    }
    static types() {
        return {
            cashCoupon: { 'type': 'array', 'itemType': QueryCashCouponsResponseBodyDataCashCoupon },
        };
    }
}
exports.QueryCashCouponsResponseBodyData = QueryCashCouponsResponseBodyData;
class QueryCommodityListResponseBodyDataCommodityList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chargeType: 'ChargeType',
            commodityCode: 'CommodityCode',
            commodityName: 'CommodityName',
        };
    }
    static types() {
        return {
            chargeType: 'string',
            commodityCode: 'string',
            commodityName: 'string',
        };
    }
}
exports.QueryCommodityListResponseBodyDataCommodityList = QueryCommodityListResponseBodyDataCommodityList;
class QueryCommodityListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityList: 'CommodityList',
        };
    }
    static types() {
        return {
            commodityList: { 'type': 'array', 'itemType': QueryCommodityListResponseBodyDataCommodityList },
        };
    }
}
exports.QueryCommodityListResponseBodyData = QueryCommodityListResponseBodyData;
class QueryCostUnitResponseBodyDataCostUnitDtoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            parentUnitId: 'ParentUnitId',
            unitId: 'UnitId',
            unitName: 'UnitName',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            parentUnitId: 'number',
            unitId: 'number',
            unitName: 'string',
        };
    }
}
exports.QueryCostUnitResponseBodyDataCostUnitDtoList = QueryCostUnitResponseBodyDataCostUnitDtoList;
class QueryCostUnitResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            costUnitDtoList: 'CostUnitDtoList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            costUnitDtoList: { 'type': 'array', 'itemType': QueryCostUnitResponseBodyDataCostUnitDtoList },
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryCostUnitResponseBodyData = QueryCostUnitResponseBodyData;
class QueryCostUnitResourceResponseBodyDataCostUnit extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerUid: 'OwnerUid',
            parentUnitId: 'ParentUnitId',
            unitId: 'UnitId',
            unitName: 'UnitName',
        };
    }
    static types() {
        return {
            ownerUid: 'number',
            parentUnitId: 'number',
            unitId: 'number',
            unitName: 'string',
        };
    }
}
exports.QueryCostUnitResourceResponseBodyDataCostUnit = QueryCostUnitResourceResponseBodyDataCostUnit;
class QueryCostUnitResourceResponseBodyDataCostUnitStatisInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceCount: 'ResourceCount',
            resourceGroupCount: 'ResourceGroupCount',
            subUnitCount: 'SubUnitCount',
            totalResourceCount: 'TotalResourceCount',
            totalResourceGroupCount: 'TotalResourceGroupCount',
            totalUserCount: 'TotalUserCount',
            userCount: 'UserCount',
        };
    }
    static types() {
        return {
            resourceCount: 'number',
            resourceGroupCount: 'number',
            subUnitCount: 'number',
            totalResourceCount: 'number',
            totalResourceGroupCount: 'number',
            totalUserCount: 'number',
            userCount: 'number',
        };
    }
}
exports.QueryCostUnitResourceResponseBodyDataCostUnitStatisInfo = QueryCostUnitResourceResponseBodyDataCostUnitStatisInfo;
class QueryCostUnitResourceResponseBodyDataResourceInstanceDtoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apportionCode: 'ApportionCode',
            apportionName: 'ApportionName',
            commodityCode: 'CommodityCode',
            commodityName: 'CommodityName',
            relatedResources: 'RelatedResources',
            resourceGroup: 'ResourceGroup',
            resourceId: 'ResourceId',
            resourceNick: 'ResourceNick',
            resourceStatus: 'ResourceStatus',
            resourceTag: 'ResourceTag',
            resourceType: 'ResourceType',
            resourceUserId: 'ResourceUserId',
            resourceUserName: 'ResourceUserName',
        };
    }
    static types() {
        return {
            apportionCode: 'string',
            apportionName: 'string',
            commodityCode: 'string',
            commodityName: 'string',
            relatedResources: 'string',
            resourceGroup: 'string',
            resourceId: 'string',
            resourceNick: 'string',
            resourceStatus: 'string',
            resourceTag: 'string',
            resourceType: 'string',
            resourceUserId: 'number',
            resourceUserName: 'string',
        };
    }
}
exports.QueryCostUnitResourceResponseBodyDataResourceInstanceDtoList = QueryCostUnitResourceResponseBodyDataResourceInstanceDtoList;
class QueryCostUnitResourceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            costUnit: 'CostUnit',
            costUnitStatisInfo: 'CostUnitStatisInfo',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            resourceInstanceDtoList: 'ResourceInstanceDtoList',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            costUnit: QueryCostUnitResourceResponseBodyDataCostUnit,
            costUnitStatisInfo: QueryCostUnitResourceResponseBodyDataCostUnitStatisInfo,
            pageNum: 'number',
            pageSize: 'number',
            resourceInstanceDtoList: { 'type': 'array', 'itemType': QueryCostUnitResourceResponseBodyDataResourceInstanceDtoList },
            totalCount: 'number',
        };
    }
}
exports.QueryCostUnitResourceResponseBodyData = QueryCostUnitResourceResponseBodyData;
class QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressListCustomerInvoiceAddress extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addressee: 'Addressee',
            bizType: 'BizType',
            city: 'City',
            county: 'County',
            deliveryAddress: 'DeliveryAddress',
            id: 'Id',
            phone: 'Phone',
            postalCode: 'PostalCode',
            province: 'Province',
            street: 'Street',
            userId: 'UserId',
            userNick: 'UserNick',
        };
    }
    static types() {
        return {
            addressee: 'string',
            bizType: 'string',
            city: 'string',
            county: 'string',
            deliveryAddress: 'string',
            id: 'number',
            phone: 'string',
            postalCode: 'string',
            province: 'string',
            street: 'string',
            userId: 'number',
            userNick: 'string',
        };
    }
}
exports.QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressListCustomerInvoiceAddress = QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressListCustomerInvoiceAddress;
class QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customerInvoiceAddress: 'CustomerInvoiceAddress',
        };
    }
    static types() {
        return {
            customerInvoiceAddress: { 'type': 'array', 'itemType': QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressListCustomerInvoiceAddress },
        };
    }
}
exports.QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressList = QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressList;
class QueryCustomerAddressListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customerInvoiceAddressList: 'CustomerInvoiceAddressList',
        };
    }
    static types() {
        return {
            customerInvoiceAddressList: QueryCustomerAddressListResponseBodyDataCustomerInvoiceAddressList,
        };
    }
}
exports.QueryCustomerAddressListResponseBodyData = QueryCustomerAddressListResponseBodyData;
class QueryDPUtilizationDetailResponseBodyDataDetailListDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deductDate: 'DeductDate',
            deductFactorTotal: 'DeductFactorTotal',
            deductHours: 'DeductHours',
            deductMeasure: 'DeductMeasure',
            deductQuantity: 'DeductQuantity',
            deductedCommodityCode: 'DeductedCommodityCode',
            deductedInstanceId: 'DeductedInstanceId',
            deductedProductDetail: 'DeductedProductDetail',
            instanceId: 'InstanceId',
            instanceSpec: 'InstanceSpec',
            region: 'Region',
            resCode: 'ResCode',
            shareUid: 'ShareUid',
            uid: 'Uid',
        };
    }
    static types() {
        return {
            deductDate: 'string',
            deductFactorTotal: 'number',
            deductHours: 'number',
            deductMeasure: 'number',
            deductQuantity: 'number',
            deductedCommodityCode: 'string',
            deductedInstanceId: 'string',
            deductedProductDetail: 'string',
            instanceId: 'string',
            instanceSpec: 'string',
            region: 'string',
            resCode: 'string',
            shareUid: 'number',
            uid: 'number',
        };
    }
}
exports.QueryDPUtilizationDetailResponseBodyDataDetailListDetailList = QueryDPUtilizationDetailResponseBodyDataDetailListDetailList;
class QueryDPUtilizationDetailResponseBodyDataDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detailList: 'DetailList',
        };
    }
    static types() {
        return {
            detailList: { 'type': 'array', 'itemType': QueryDPUtilizationDetailResponseBodyDataDetailListDetailList },
        };
    }
}
exports.QueryDPUtilizationDetailResponseBodyDataDetailList = QueryDPUtilizationDetailResponseBodyDataDetailList;
class QueryDPUtilizationDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detailList: 'DetailList',
            nextToken: 'NextToken',
        };
    }
    static types() {
        return {
            detailList: QueryDPUtilizationDetailResponseBodyDataDetailList,
            nextToken: 'string',
        };
    }
}
exports.QueryDPUtilizationDetailResponseBodyData = QueryDPUtilizationDetailResponseBodyData;
class QueryEvaluateListResponseBodyDataEvaluateListEvaluate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billCycle: 'BillCycle',
            billId: 'BillId',
            bizTime: 'BizTime',
            bizType: 'BizType',
            canInvoiceAmount: 'CanInvoiceAmount',
            gmtCreate: 'GmtCreate',
            gmtModified: 'GmtModified',
            id: 'Id',
            invoicedAmount: 'InvoicedAmount',
            itemId: 'ItemId',
            name: 'Name',
            offsetAcceptAmount: 'OffsetAcceptAmount',
            offsetCostAmount: 'OffsetCostAmount',
            opId: 'OpId',
            originalAmount: 'OriginalAmount',
            outBizId: 'OutBizId',
            presentAmount: 'PresentAmount',
            status: 'Status',
            type: 'Type',
            userId: 'UserId',
            userNick: 'UserNick',
        };
    }
    static types() {
        return {
            billCycle: 'string',
            billId: 'number',
            bizTime: 'string',
            bizType: 'string',
            canInvoiceAmount: 'number',
            gmtCreate: 'string',
            gmtModified: 'string',
            id: 'number',
            invoicedAmount: 'number',
            itemId: 'number',
            name: 'string',
            offsetAcceptAmount: 'number',
            offsetCostAmount: 'number',
            opId: 'string',
            originalAmount: 'number',
            outBizId: 'string',
            presentAmount: 'number',
            status: 'number',
            type: 'number',
            userId: 'number',
            userNick: 'string',
        };
    }
}
exports.QueryEvaluateListResponseBodyDataEvaluateListEvaluate = QueryEvaluateListResponseBodyDataEvaluateListEvaluate;
class QueryEvaluateListResponseBodyDataEvaluateList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            evaluate: 'Evaluate',
        };
    }
    static types() {
        return {
            evaluate: { 'type': 'array', 'itemType': QueryEvaluateListResponseBodyDataEvaluateListEvaluate },
        };
    }
}
exports.QueryEvaluateListResponseBodyDataEvaluateList = QueryEvaluateListResponseBodyDataEvaluateList;
class QueryEvaluateListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            evaluateList: 'EvaluateList',
            hostId: 'HostId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
            totalInvoiceAmount: 'TotalInvoiceAmount',
            totalUnAppliedInvoiceAmount: 'TotalUnAppliedInvoiceAmount',
        };
    }
    static types() {
        return {
            evaluateList: QueryEvaluateListResponseBodyDataEvaluateList,
            hostId: 'string',
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
            totalInvoiceAmount: 'number',
            totalUnAppliedInvoiceAmount: 'number',
        };
    }
}
exports.QueryEvaluateListResponseBodyData = QueryEvaluateListResponseBodyData;
class QueryFinancialAccountInfoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'AccountType',
            isFinancialAccount: 'IsFinancialAccount',
            memberGroupId: 'MemberGroupId',
            memberGroupName: 'MemberGroupName',
            memberNickName: 'MemberNickName',
            userName: 'UserName',
        };
    }
    static types() {
        return {
            accountType: 'string',
            isFinancialAccount: 'boolean',
            memberGroupId: 'number',
            memberGroupName: 'string',
            memberNickName: 'string',
            userName: 'string',
        };
    }
}
exports.QueryFinancialAccountInfoResponseBodyData = QueryFinancialAccountInfoResponseBodyData;
class QueryInstanceBillResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            billingDate: 'BillingDate',
            billingItem: 'BillingItem',
            billingType: 'BillingType',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            costUnit: 'CostUnit',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            deductedByResourcePackage: 'DeductedByResourcePackage',
            instanceConfig: 'InstanceConfig',
            instanceID: 'InstanceID',
            instanceSpec: 'InstanceSpec',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            listPrice: 'ListPrice',
            listPriceUnit: 'ListPriceUnit',
            nickName: 'NickName',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            region: 'Region',
            resourceGroup: 'ResourceGroup',
            servicePeriod: 'ServicePeriod',
            servicePeriodUnit: 'ServicePeriodUnit',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            usage: 'Usage',
            usageUnit: 'UsageUnit',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            billingDate: 'string',
            billingItem: 'string',
            billingType: 'string',
            cashAmount: 'number',
            commodityCode: 'string',
            costUnit: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            deductedByResourcePackage: 'string',
            instanceConfig: 'string',
            instanceID: 'string',
            instanceSpec: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            item: 'string',
            listPrice: 'string',
            listPriceUnit: 'string',
            nickName: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            region: 'string',
            resourceGroup: 'string',
            servicePeriod: 'string',
            servicePeriodUnit: 'string',
            subscriptionType: 'string',
            tag: 'string',
            usage: 'string',
            usageUnit: 'string',
            zone: 'string',
        };
    }
}
exports.QueryInstanceBillResponseBodyDataItemsItem = QueryInstanceBillResponseBodyDataItemsItem;
class QueryInstanceBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QueryInstanceBillResponseBodyDataItemsItem },
        };
    }
}
exports.QueryInstanceBillResponseBodyDataItems = QueryInstanceBillResponseBodyDataItems;
class QueryInstanceBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: QueryInstanceBillResponseBodyDataItems,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryInstanceBillResponseBodyData = QueryInstanceBillResponseBodyData;
class QueryInstanceByTagRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.QueryInstanceByTagRequestTag = QueryInstanceByTagRequestTag;
class QueryInstanceByTagResponseBodyTagResourceTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.QueryInstanceByTagResponseBodyTagResourceTag = QueryInstanceByTagResponseBodyTagResourceTag;
class QueryInstanceByTagResponseBodyTagResource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceId: 'ResourceId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            resourceId: 'string',
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': QueryInstanceByTagResponseBodyTagResourceTag },
        };
    }
}
exports.QueryInstanceByTagResponseBodyTagResource = QueryInstanceByTagResponseBodyTagResource;
class QueryInstanceGaapCostResponseBodyDataModulesModule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountingUnit: 'AccountingUnit',
            billType: 'BillType',
            billingCycle: 'BillingCycle',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            gaapDeductedByCashCoupons: 'GaapDeductedByCashCoupons',
            gaapDeductedByCoupons: 'GaapDeductedByCoupons',
            gaapDeductedByPrepaidCard: 'GaapDeductedByPrepaidCard',
            gaapPaymentAmount: 'GaapPaymentAmount',
            gaapPretaxAmount: 'GaapPretaxAmount',
            gaapPretaxAmountLocal: 'GaapPretaxAmountLocal',
            gaapPretaxGrossAmount: 'GaapPretaxGrossAmount',
            gaapPricingDiscount: 'GaapPricingDiscount',
            instanceID: 'InstanceID',
            monthGaapDeductedByCashCoupons: 'MonthGaapDeductedByCashCoupons',
            monthGaapDeductedByCoupons: 'MonthGaapDeductedByCoupons',
            monthGaapDeductedByPrepaidCard: 'MonthGaapDeductedByPrepaidCard',
            monthGaapPaymentAmount: 'MonthGaapPaymentAmount',
            monthGaapPretaxAmount: 'MonthGaapPretaxAmount',
            monthGaapPretaxAmountLocal: 'MonthGaapPretaxAmountLocal',
            monthGaapPretaxGrossAmount: 'MonthGaapPretaxGrossAmount',
            monthGaapPricingDiscount: 'MonthGaapPricingDiscount',
            orderId: 'OrderId',
            orderType: 'OrderType',
            ownerID: 'OwnerID',
            payTime: 'PayTime',
            payerAccount: 'PayerAccount',
            paymentAmount: 'PaymentAmount',
            paymentCurrency: 'PaymentCurrency',
            pretaxAmount: 'PretaxAmount',
            pretaxAmountLocal: 'PretaxAmountLocal',
            pretaxGrossAmount: 'PretaxGrossAmount',
            pricingDiscount: 'PricingDiscount',
            productCode: 'ProductCode',
            productType: 'ProductType',
            region: 'Region',
            resourceGroup: 'ResourceGroup',
            subOrderId: 'SubOrderId',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            unallocatedDeductedByCashCoupons: 'UnallocatedDeductedByCashCoupons',
            unallocatedDeductedByCoupons: 'UnallocatedDeductedByCoupons',
            unallocatedDeductedByPrepaidCard: 'UnallocatedDeductedByPrepaidCard',
            unallocatedPaymentAmount: 'UnallocatedPaymentAmount',
            unallocatedPretaxAmount: 'UnallocatedPretaxAmount',
            unallocatedPretaxAmountLocal: 'UnallocatedPretaxAmountLocal',
            unallocatedPretaxGrossAmount: 'UnallocatedPretaxGrossAmount',
            unallocatedPricingDiscount: 'UnallocatedPricingDiscount',
            usageEndDate: 'UsageEndDate',
            usageStartDate: 'UsageStartDate',
        };
    }
    static types() {
        return {
            accountingUnit: 'string',
            billType: 'string',
            billingCycle: 'string',
            currency: 'string',
            deductedByCashCoupons: 'string',
            deductedByCoupons: 'string',
            deductedByPrepaidCard: 'string',
            gaapDeductedByCashCoupons: 'string',
            gaapDeductedByCoupons: 'string',
            gaapDeductedByPrepaidCard: 'string',
            gaapPaymentAmount: 'string',
            gaapPretaxAmount: 'string',
            gaapPretaxAmountLocal: 'string',
            gaapPretaxGrossAmount: 'string',
            gaapPricingDiscount: 'string',
            instanceID: 'string',
            monthGaapDeductedByCashCoupons: 'string',
            monthGaapDeductedByCoupons: 'string',
            monthGaapDeductedByPrepaidCard: 'string',
            monthGaapPaymentAmount: 'string',
            monthGaapPretaxAmount: 'string',
            monthGaapPretaxAmountLocal: 'string',
            monthGaapPretaxGrossAmount: 'string',
            monthGaapPricingDiscount: 'string',
            orderId: 'string',
            orderType: 'string',
            ownerID: 'string',
            payTime: 'string',
            payerAccount: 'string',
            paymentAmount: 'string',
            paymentCurrency: 'string',
            pretaxAmount: 'string',
            pretaxAmountLocal: 'string',
            pretaxGrossAmount: 'string',
            pricingDiscount: 'string',
            productCode: 'string',
            productType: 'string',
            region: 'string',
            resourceGroup: 'string',
            subOrderId: 'string',
            subscriptionType: 'string',
            tag: 'string',
            unallocatedDeductedByCashCoupons: 'string',
            unallocatedDeductedByCoupons: 'string',
            unallocatedDeductedByPrepaidCard: 'string',
            unallocatedPaymentAmount: 'string',
            unallocatedPretaxAmount: 'string',
            unallocatedPretaxAmountLocal: 'string',
            unallocatedPretaxGrossAmount: 'string',
            unallocatedPricingDiscount: 'string',
            usageEndDate: 'string',
            usageStartDate: 'string',
        };
    }
}
exports.QueryInstanceGaapCostResponseBodyDataModulesModule = QueryInstanceGaapCostResponseBodyDataModulesModule;
class QueryInstanceGaapCostResponseBodyDataModules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            module: 'Module',
        };
    }
    static types() {
        return {
            module: { 'type': 'array', 'itemType': QueryInstanceGaapCostResponseBodyDataModulesModule },
        };
    }
}
exports.QueryInstanceGaapCostResponseBodyDataModules = QueryInstanceGaapCostResponseBodyDataModules;
class QueryInstanceGaapCostResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            modules: 'Modules',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            hostId: 'string',
            modules: QueryInstanceGaapCostResponseBodyDataModules,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryInstanceGaapCostResponseBodyData = QueryInstanceGaapCostResponseBodyData;
class QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceListCustomerInvoice extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustType: 'AdjustType',
            bank: 'Bank',
            bankNo: 'BankNo',
            customerType: 'CustomerType',
            defaultRemark: 'DefaultRemark',
            endCycle: 'EndCycle',
            gmtCreate: 'GmtCreate',
            id: 'Id',
            invoiceTitle: 'InvoiceTitle',
            issueType: 'IssueType',
            operatingLicenseAddress: 'OperatingLicenseAddress',
            operatingLicensePhone: 'OperatingLicensePhone',
            registerNo: 'RegisterNo',
            startCycle: 'StartCycle',
            status: 'Status',
            taxationLicense: 'TaxationLicense',
            taxpayerType: 'TaxpayerType',
            titleChangeInstructions: 'TitleChangeInstructions',
            type: 'Type',
            userId: 'UserId',
            userNick: 'UserNick',
        };
    }
    static types() {
        return {
            adjustType: 'number',
            bank: 'string',
            bankNo: 'string',
            customerType: 'number',
            defaultRemark: 'string',
            endCycle: 'number',
            gmtCreate: 'string',
            id: 'number',
            invoiceTitle: 'string',
            issueType: 'number',
            operatingLicenseAddress: 'string',
            operatingLicensePhone: 'string',
            registerNo: 'string',
            startCycle: 'number',
            status: 'number',
            taxationLicense: 'string',
            taxpayerType: 'number',
            titleChangeInstructions: 'string',
            type: 'number',
            userId: 'number',
            userNick: 'string',
        };
    }
}
exports.QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceListCustomerInvoice = QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceListCustomerInvoice;
class QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customerInvoice: 'CustomerInvoice',
        };
    }
    static types() {
        return {
            customerInvoice: { 'type': 'array', 'itemType': QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceListCustomerInvoice },
        };
    }
}
exports.QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceList = QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceList;
class QueryInvoicingCustomerListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customerInvoiceList: 'CustomerInvoiceList',
        };
    }
    static types() {
        return {
            customerInvoiceList: QueryInvoicingCustomerListResponseBodyDataCustomerInvoiceList,
        };
    }
}
exports.QueryInvoicingCustomerListResponseBodyData = QueryInvoicingCustomerListResponseBodyData;
class QueryOrdersResponseBodyDataOrderListOrder extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            afterTaxAmount: 'AfterTaxAmount',
            commodityCode: 'CommodityCode',
            createTime: 'CreateTime',
            currency: 'Currency',
            orderId: 'OrderId',
            orderType: 'OrderType',
            paymentCurrency: 'PaymentCurrency',
            paymentStatus: 'PaymentStatus',
            paymentTime: 'PaymentTime',
            pretaxAmount: 'PretaxAmount',
            pretaxAmountLocal: 'PretaxAmountLocal',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productType: 'ProductType',
            relatedOrderId: 'RelatedOrderId',
            subscriptionType: 'SubscriptionType',
            tax: 'Tax',
        };
    }
    static types() {
        return {
            afterTaxAmount: 'string',
            commodityCode: 'string',
            createTime: 'string',
            currency: 'string',
            orderId: 'string',
            orderType: 'string',
            paymentCurrency: 'string',
            paymentStatus: 'string',
            paymentTime: 'string',
            pretaxAmount: 'string',
            pretaxAmountLocal: 'string',
            pretaxGrossAmount: 'string',
            productCode: 'string',
            productType: 'string',
            relatedOrderId: 'string',
            subscriptionType: 'string',
            tax: 'string',
        };
    }
}
exports.QueryOrdersResponseBodyDataOrderListOrder = QueryOrdersResponseBodyDataOrderListOrder;
class QueryOrdersResponseBodyDataOrderList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            order: 'Order',
        };
    }
    static types() {
        return {
            order: { 'type': 'array', 'itemType': QueryOrdersResponseBodyDataOrderListOrder },
        };
    }
}
exports.QueryOrdersResponseBodyDataOrderList = QueryOrdersResponseBodyDataOrderList;
class QueryOrdersResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostName: 'HostName',
            orderList: 'OrderList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            hostName: 'string',
            orderList: QueryOrdersResponseBodyDataOrderList,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryOrdersResponseBodyData = QueryOrdersResponseBodyData;
class QueryPermissionListResponseBodyDataPermissionList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            permissionCode: 'PermissionCode',
            permissionName: 'PermissionName',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            endTime: 'string',
            permissionCode: 'string',
            permissionName: 'string',
            startTime: 'string',
        };
    }
}
exports.QueryPermissionListResponseBodyDataPermissionList = QueryPermissionListResponseBodyDataPermissionList;
class QueryPermissionListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            masterId: 'MasterId',
            memberId: 'MemberId',
            permissionList: 'PermissionList',
            relationType: 'RelationType',
            setupTime: 'SetupTime',
            startTime: 'StartTime',
            state: 'State',
        };
    }
    static types() {
        return {
            endTime: 'string',
            masterId: 'number',
            memberId: 'number',
            permissionList: { 'type': 'array', 'itemType': QueryPermissionListResponseBodyDataPermissionList },
            relationType: 'string',
            setupTime: 'string',
            startTime: 'string',
            state: 'string',
        };
    }
}
exports.QueryPermissionListResponseBodyData = QueryPermissionListResponseBodyData;
class QueryPrepaidCardsResponseBodyDataPrepaidCard extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicableProducts: 'ApplicableProducts',
            applicableScenarios: 'ApplicableScenarios',
            balance: 'Balance',
            effectiveTime: 'EffectiveTime',
            expiryTime: 'ExpiryTime',
            grantedTime: 'GrantedTime',
            nominalValue: 'NominalValue',
            prepaidCardId: 'PrepaidCardId',
            prepaidCardNo: 'PrepaidCardNo',
            status: 'Status',
        };
    }
    static types() {
        return {
            applicableProducts: 'string',
            applicableScenarios: 'string',
            balance: 'string',
            effectiveTime: 'string',
            expiryTime: 'string',
            grantedTime: 'string',
            nominalValue: 'string',
            prepaidCardId: 'number',
            prepaidCardNo: 'string',
            status: 'string',
        };
    }
}
exports.QueryPrepaidCardsResponseBodyDataPrepaidCard = QueryPrepaidCardsResponseBodyDataPrepaidCard;
class QueryPrepaidCardsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            prepaidCard: 'PrepaidCard',
        };
    }
    static types() {
        return {
            prepaidCard: { 'type': 'array', 'itemType': QueryPrepaidCardsResponseBodyDataPrepaidCard },
        };
    }
}
exports.QueryPrepaidCardsResponseBodyData = QueryPrepaidCardsResponseBodyData;
class QueryPriceEntityListResponseBodyDataPriceEntityInfoListPriceFactorList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            priceFactorCode: 'PriceFactorCode',
            priceFactorName: 'PriceFactorName',
            priceFactorValueList: 'PriceFactorValueList',
        };
    }
    static types() {
        return {
            priceFactorCode: 'string',
            priceFactorName: 'string',
            priceFactorValueList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryPriceEntityListResponseBodyDataPriceEntityInfoListPriceFactorList = QueryPriceEntityListResponseBodyDataPriceEntityInfoListPriceFactorList;
class QueryPriceEntityListResponseBodyDataPriceEntityInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            priceEntityCode: 'PriceEntityCode',
            priceEntityName: 'PriceEntityName',
            priceFactorList: 'PriceFactorList',
        };
    }
    static types() {
        return {
            priceEntityCode: 'string',
            priceEntityName: 'string',
            priceFactorList: { 'type': 'array', 'itemType': QueryPriceEntityListResponseBodyDataPriceEntityInfoListPriceFactorList },
        };
    }
}
exports.QueryPriceEntityListResponseBodyDataPriceEntityInfoList = QueryPriceEntityListResponseBodyDataPriceEntityInfoList;
class QueryPriceEntityListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            priceEntityInfoList: 'PriceEntityInfoList',
        };
    }
    static types() {
        return {
            priceEntityInfoList: { 'type': 'array', 'itemType': QueryPriceEntityListResponseBodyDataPriceEntityInfoList },
        };
    }
}
exports.QueryPriceEntityListResponseBodyData = QueryPriceEntityListResponseBodyData;
class QueryProductListResponseBodyDataProductListProduct extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            productCode: 'ProductCode',
            productName: 'ProductName',
            productType: 'ProductType',
            subscriptionType: 'SubscriptionType',
        };
    }
    static types() {
        return {
            productCode: 'string',
            productName: 'string',
            productType: 'string',
            subscriptionType: 'string',
        };
    }
}
exports.QueryProductListResponseBodyDataProductListProduct = QueryProductListResponseBodyDataProductListProduct;
class QueryProductListResponseBodyDataProductList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            product: 'Product',
        };
    }
    static types() {
        return {
            product: { 'type': 'array', 'itemType': QueryProductListResponseBodyDataProductListProduct },
        };
    }
}
exports.QueryProductListResponseBodyDataProductList = QueryProductListResponseBodyDataProductList;
class QueryProductListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            productList: 'ProductList',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            pageNum: 'number',
            pageSize: 'number',
            productList: QueryProductListResponseBodyDataProductList,
            totalCount: 'number',
        };
    }
}
exports.QueryProductListResponseBodyData = QueryProductListResponseBodyData;
class QueryRIUtilizationDetailResponseBodyDataDetailListDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deductDate: 'DeductDate',
            deductFactorTotal: 'DeductFactorTotal',
            deductHours: 'DeductHours',
            deductQuantity: 'DeductQuantity',
            deductedCommodityCode: 'DeductedCommodityCode',
            deductedInstanceId: 'DeductedInstanceId',
            deductedProductDetail: 'DeductedProductDetail',
            instanceSpec: 'InstanceSpec',
            RIInstanceId: 'RIInstanceId',
        };
    }
    static types() {
        return {
            deductDate: 'string',
            deductFactorTotal: 'number',
            deductHours: 'string',
            deductQuantity: 'number',
            deductedCommodityCode: 'string',
            deductedInstanceId: 'string',
            deductedProductDetail: 'string',
            instanceSpec: 'string',
            RIInstanceId: 'string',
        };
    }
}
exports.QueryRIUtilizationDetailResponseBodyDataDetailListDetailList = QueryRIUtilizationDetailResponseBodyDataDetailListDetailList;
class QueryRIUtilizationDetailResponseBodyDataDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detailList: 'DetailList',
        };
    }
    static types() {
        return {
            detailList: { 'type': 'array', 'itemType': QueryRIUtilizationDetailResponseBodyDataDetailListDetailList },
        };
    }
}
exports.QueryRIUtilizationDetailResponseBodyDataDetailList = QueryRIUtilizationDetailResponseBodyDataDetailList;
class QueryRIUtilizationDetailResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detailList: 'DetailList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            detailList: QueryRIUtilizationDetailResponseBodyDataDetailList,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryRIUtilizationDetailResponseBodyData = QueryRIUtilizationDetailResponseBodyData;
class QueryRedeemResponseBodyDataRedeemRedeem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicableProducts: 'ApplicableProducts',
            balance: 'Balance',
            effectiveTime: 'EffectiveTime',
            expiryTime: 'ExpiryTime',
            grantedTime: 'GrantedTime',
            nominalValue: 'NominalValue',
            redeemId: 'RedeemId',
            redeemNo: 'RedeemNo',
            specification: 'Specification',
            status: 'Status',
        };
    }
    static types() {
        return {
            applicableProducts: 'string',
            balance: 'string',
            effectiveTime: 'string',
            expiryTime: 'string',
            grantedTime: 'string',
            nominalValue: 'string',
            redeemId: 'string',
            redeemNo: 'string',
            specification: 'string',
            status: 'string',
        };
    }
}
exports.QueryRedeemResponseBodyDataRedeemRedeem = QueryRedeemResponseBodyDataRedeemRedeem;
class QueryRedeemResponseBodyDataRedeem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            redeem: 'Redeem',
        };
    }
    static types() {
        return {
            redeem: { 'type': 'array', 'itemType': QueryRedeemResponseBodyDataRedeemRedeem },
        };
    }
}
exports.QueryRedeemResponseBodyDataRedeem = QueryRedeemResponseBodyDataRedeem;
class QueryRedeemResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            redeem: 'Redeem',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            pageNum: 'number',
            pageSize: 'number',
            redeem: QueryRedeemResponseBodyDataRedeem,
            totalCount: 'number',
        };
    }
}
exports.QueryRedeemResponseBodyData = QueryRedeemResponseBodyData;
class QueryRelationListResponseBodyDataFinancialRelationInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'AccountId',
            accountName: 'AccountName',
            accountNickName: 'AccountNickName',
            accountType: 'AccountType',
            endTime: 'EndTime',
            relationId: 'RelationId',
            relationType: 'RelationType',
            setupTime: 'SetupTime',
            startTime: 'StartTime',
            state: 'State',
        };
    }
    static types() {
        return {
            accountId: 'number',
            accountName: 'string',
            accountNickName: 'string',
            accountType: 'string',
            endTime: 'string',
            relationId: 'number',
            relationType: 'string',
            setupTime: 'string',
            startTime: 'string',
            state: 'string',
        };
    }
}
exports.QueryRelationListResponseBodyDataFinancialRelationInfoList = QueryRelationListResponseBodyDataFinancialRelationInfoList;
class QueryRelationListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            financialRelationInfoList: 'FinancialRelationInfoList',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            financialRelationInfoList: { 'type': 'array', 'itemType': QueryRelationListResponseBodyDataFinancialRelationInfoList },
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QueryRelationListResponseBodyData = QueryRelationListResponseBodyData;
class QueryResellerUserAlarmThresholdResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            denominator: 'Denominator',
            numerator: 'Numerator',
            thresholdAmount: 'ThresholdAmount',
            thresholdType: 'ThresholdType',
        };
    }
    static types() {
        return {
            denominator: 'number',
            numerator: 'number',
            thresholdAmount: 'string',
            thresholdType: 'number',
        };
    }
}
exports.QueryResellerUserAlarmThresholdResponseBodyData = QueryResellerUserAlarmThresholdResponseBodyData;
class QueryResourcePackageInstancesResponseBodyDataInstancesInstanceApplicableProducts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            product: 'Product',
        };
    }
    static types() {
        return {
            product: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryResourcePackageInstancesResponseBodyDataInstancesInstanceApplicableProducts = QueryResourcePackageInstancesResponseBodyDataInstancesInstanceApplicableProducts;
class QueryResourcePackageInstancesResponseBodyDataInstancesInstance extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicableProducts: 'ApplicableProducts',
            commodityCode: 'CommodityCode',
            deductType: 'DeductType',
            effectiveTime: 'EffectiveTime',
            expiryTime: 'ExpiryTime',
            instanceId: 'InstanceId',
            packageType: 'PackageType',
            region: 'Region',
            remainingAmount: 'RemainingAmount',
            remainingAmountUnit: 'RemainingAmountUnit',
            remark: 'Remark',
            status: 'Status',
            totalAmount: 'TotalAmount',
            totalAmountUnit: 'TotalAmountUnit',
        };
    }
    static types() {
        return {
            applicableProducts: QueryResourcePackageInstancesResponseBodyDataInstancesInstanceApplicableProducts,
            commodityCode: 'string',
            deductType: 'string',
            effectiveTime: 'string',
            expiryTime: 'string',
            instanceId: 'string',
            packageType: 'string',
            region: 'string',
            remainingAmount: 'string',
            remainingAmountUnit: 'string',
            remark: 'string',
            status: 'string',
            totalAmount: 'string',
            totalAmountUnit: 'string',
        };
    }
}
exports.QueryResourcePackageInstancesResponseBodyDataInstancesInstance = QueryResourcePackageInstancesResponseBodyDataInstancesInstance;
class QueryResourcePackageInstancesResponseBodyDataInstances extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instance: 'Instance',
        };
    }
    static types() {
        return {
            instance: { 'type': 'array', 'itemType': QueryResourcePackageInstancesResponseBodyDataInstancesInstance },
        };
    }
}
exports.QueryResourcePackageInstancesResponseBodyDataInstances = QueryResourcePackageInstancesResponseBodyDataInstances;
class QueryResourcePackageInstancesResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            instances: 'Instances',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            hostId: 'string',
            instances: QueryResourcePackageInstancesResponseBodyDataInstances,
            pageNum: 'string',
            pageSize: 'string',
            totalCount: 'string',
        };
    }
}
exports.QueryResourcePackageInstancesResponseBodyData = QueryResourcePackageInstancesResponseBodyData;
class QuerySavingsPlansDeductLogResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            billModule: 'BillModule',
            deductCommodity: 'DeductCommodity',
            deductFee: 'DeductFee',
            deductInstanceId: 'DeductInstanceId',
            deductRate: 'DeductRate',
            discountRate: 'DiscountRate',
            endTime: 'EndTime',
            instanceId: 'InstanceId',
            ownerId: 'OwnerId',
            savingsType: 'SavingsType',
            startTime: 'StartTime',
            userId: 'UserId',
        };
    }
    static types() {
        return {
            billModule: 'string',
            deductCommodity: 'string',
            deductFee: 'string',
            deductInstanceId: 'string',
            deductRate: 'string',
            discountRate: 'string',
            endTime: 'string',
            instanceId: 'string',
            ownerId: 'number',
            savingsType: 'string',
            startTime: 'string',
            userId: 'number',
        };
    }
}
exports.QuerySavingsPlansDeductLogResponseBodyDataItems = QuerySavingsPlansDeductLogResponseBodyDataItems;
class QuerySavingsPlansDeductLogResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySavingsPlansDeductLogResponseBodyDataItems },
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QuerySavingsPlansDeductLogResponseBodyData = QuerySavingsPlansDeductLogResponseBodyData;
class QuerySavingsPlansDiscountResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodityName: 'CommodityName',
            contractDiscountRate: 'ContractDiscountRate',
            cycle: 'Cycle',
            discountRate: 'DiscountRate',
            moduleName: 'ModuleName',
            payMode: 'PayMode',
            region: 'Region',
            spec: 'Spec',
            spnType: 'SpnType',
        };
    }
    static types() {
        return {
            commodityName: 'string',
            contractDiscountRate: 'string',
            cycle: 'string',
            discountRate: 'string',
            moduleName: 'string',
            payMode: 'string',
            region: 'string',
            spec: 'string',
            spnType: 'string',
        };
    }
}
exports.QuerySavingsPlansDiscountResponseBodyDataItems = QuerySavingsPlansDiscountResponseBodyDataItems;
class QuerySavingsPlansDiscountResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            items: 'Items',
        };
    }
    static types() {
        return {
            hostId: 'string',
            items: { 'type': 'array', 'itemType': QuerySavingsPlansDiscountResponseBodyDataItems },
        };
    }
}
exports.QuerySavingsPlansDiscountResponseBodyData = QuerySavingsPlansDiscountResponseBodyData;
class QuerySavingsPlansInstanceRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.QuerySavingsPlansInstanceRequestTag = QuerySavingsPlansInstanceRequestTag;
class QuerySavingsPlansInstanceResponseBodyDataItemsTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.QuerySavingsPlansInstanceResponseBodyDataItemsTags = QuerySavingsPlansInstanceResponseBodyDataItemsTags;
class QuerySavingsPlansInstanceResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allocationStatus: 'AllocationStatus',
            currency: 'Currency',
            cycle: 'Cycle',
            deductCycleType: 'DeductCycleType',
            endTime: 'EndTime',
            endTimestamp: 'EndTimestamp',
            instanceFamily: 'InstanceFamily',
            instanceId: 'InstanceId',
            lastBillTotalUsage: 'LastBillTotalUsage',
            lastBillUtilization: 'LastBillUtilization',
            payMode: 'PayMode',
            poolValue: 'PoolValue',
            prepayFee: 'PrepayFee',
            region: 'Region',
            restPoolValue: 'RestPoolValue',
            savingsType: 'SavingsType',
            startTime: 'StartTime',
            startTimestamp: 'StartTimestamp',
            status: 'Status',
            tags: 'Tags',
            totalSave: 'TotalSave',
            utilization: 'Utilization',
        };
    }
    static types() {
        return {
            allocationStatus: 'string',
            currency: 'string',
            cycle: 'string',
            deductCycleType: 'string',
            endTime: 'string',
            endTimestamp: 'number',
            instanceFamily: 'string',
            instanceId: 'string',
            lastBillTotalUsage: 'string',
            lastBillUtilization: 'string',
            payMode: 'string',
            poolValue: 'string',
            prepayFee: 'string',
            region: 'string',
            restPoolValue: 'string',
            savingsType: 'string',
            startTime: 'string',
            startTimestamp: 'number',
            status: 'string',
            tags: { 'type': 'array', 'itemType': QuerySavingsPlansInstanceResponseBodyDataItemsTags },
            totalSave: 'string',
            utilization: 'string',
        };
    }
}
exports.QuerySavingsPlansInstanceResponseBodyDataItems = QuerySavingsPlansInstanceResponseBodyDataItems;
class QuerySavingsPlansInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': QuerySavingsPlansInstanceResponseBodyDataItems },
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QuerySavingsPlansInstanceResponseBodyData = QuerySavingsPlansInstanceResponseBodyData;
class QuerySettleBillResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            afterTaxAmount: 'AfterTaxAmount',
            billAccountID: 'BillAccountID',
            billAccountName: 'BillAccountName',
            bizType: 'BizType',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            paymentCurrency: 'PaymentCurrency',
            paymentTime: 'PaymentTime',
            paymentTransactionID: 'PaymentTransactionID',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxAmountLocal: 'PretaxAmountLocal',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            recordID: 'RecordID',
            roundDownDiscount: 'RoundDownDiscount',
            status: 'Status',
            subOrderId: 'SubOrderId',
            subscriptionType: 'SubscriptionType',
            tax: 'Tax',
            usageEndTime: 'UsageEndTime',
            usageStartTime: 'UsageStartTime',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            afterTaxAmount: 'number',
            billAccountID: 'string',
            billAccountName: 'string',
            bizType: 'string',
            cashAmount: 'number',
            commodityCode: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            invoiceDiscount: 'number',
            item: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            paymentCurrency: 'string',
            paymentTime: 'string',
            paymentTransactionID: 'string',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxAmountLocal: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            recordID: 'string',
            roundDownDiscount: 'string',
            status: 'string',
            subOrderId: 'string',
            subscriptionType: 'string',
            tax: 'number',
            usageEndTime: 'string',
            usageStartTime: 'string',
        };
    }
}
exports.QuerySettleBillResponseBodyDataItemsItem = QuerySettleBillResponseBodyDataItemsItem;
class QuerySettleBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QuerySettleBillResponseBodyDataItemsItem },
        };
    }
}
exports.QuerySettleBillResponseBodyDataItems = QuerySettleBillResponseBodyDataItems;
class QuerySettleBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: QuerySettleBillResponseBodyDataItems,
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.QuerySettleBillResponseBodyData = QuerySettleBillResponseBodyData;
class QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceListRangeList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            factorCode: 'FactorCode',
            max: 'Max',
            min: 'Min',
            type: 'Type',
        };
    }
    static types() {
        return {
            factorCode: 'string',
            max: 'string',
            min: 'string',
            type: 'string',
        };
    }
}
exports.QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceListRangeList = QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceListRangeList;
class QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cskuCode: 'CskuCode',
            currency: 'Currency',
            price: 'Price',
            priceMode: 'PriceMode',
            priceType: 'PriceType',
            priceUnit: 'PriceUnit',
            rangeList: 'RangeList',
            usageUnit: 'UsageUnit',
        };
    }
    static types() {
        return {
            cskuCode: 'string',
            currency: 'string',
            price: 'string',
            priceMode: 'string',
            priceType: 'string',
            priceUnit: 'string',
            rangeList: { 'type': 'array', 'itemType': QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceListRangeList },
            usageUnit: 'string',
        };
    }
}
exports.QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceList = QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceList;
class QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cskuPriceList: 'CskuPriceList',
            skuCode: 'SkuCode',
            skuFactorMap: 'SkuFactorMap',
        };
    }
    static types() {
        return {
            cskuPriceList: { 'type': 'array', 'itemType': QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceListCskuPriceList },
            skuCode: 'string',
            skuFactorMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceList = QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceList;
class QuerySkuPriceListResponseBodyDataSkuPricePage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextPageToken: 'NextPageToken',
            skuPriceList: 'SkuPriceList',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            nextPageToken: 'string',
            skuPriceList: { 'type': 'array', 'itemType': QuerySkuPriceListResponseBodyDataSkuPricePageSkuPriceList },
            totalCount: 'number',
        };
    }
}
exports.QuerySkuPriceListResponseBodyDataSkuPricePage = QuerySkuPriceListResponseBodyDataSkuPricePage;
class QuerySkuPriceListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            skuPricePage: 'SkuPricePage',
        };
    }
    static types() {
        return {
            skuPricePage: QuerySkuPriceListResponseBodyDataSkuPricePage,
        };
    }
}
exports.QuerySkuPriceListResponseBodyData = QuerySkuPriceListResponseBodyData;
class QuerySplitItemBillResponseBodyDataItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustAmount: 'AdjustAmount',
            billingDate: 'BillingDate',
            billingItem: 'BillingItem',
            billingType: 'BillingType',
            cashAmount: 'CashAmount',
            commodityCode: 'CommodityCode',
            costUnit: 'CostUnit',
            currency: 'Currency',
            deductedByCashCoupons: 'DeductedByCashCoupons',
            deductedByCoupons: 'DeductedByCoupons',
            deductedByPrepaidCard: 'DeductedByPrepaidCard',
            deductedByResourcePackage: 'DeductedByResourcePackage',
            instanceConfig: 'InstanceConfig',
            instanceID: 'InstanceID',
            instanceSpec: 'InstanceSpec',
            internetIP: 'InternetIP',
            intranetIP: 'IntranetIP',
            invoiceDiscount: 'InvoiceDiscount',
            item: 'Item',
            listPrice: 'ListPrice',
            listPriceUnit: 'ListPriceUnit',
            nickName: 'NickName',
            outstandingAmount: 'OutstandingAmount',
            ownerID: 'OwnerID',
            paymentAmount: 'PaymentAmount',
            pipCode: 'PipCode',
            pretaxAmount: 'PretaxAmount',
            pretaxGrossAmount: 'PretaxGrossAmount',
            productCode: 'ProductCode',
            productDetail: 'ProductDetail',
            productName: 'ProductName',
            productType: 'ProductType',
            region: 'Region',
            resourceGroup: 'ResourceGroup',
            servicePeriod: 'ServicePeriod',
            servicePeriodUnit: 'ServicePeriodUnit',
            splitAccountID: 'SplitAccountID',
            splitAccountName: 'SplitAccountName',
            splitBillingCycle: 'SplitBillingCycle',
            splitCommodityCode: 'SplitCommodityCode',
            splitItemID: 'SplitItemID',
            splitItemName: 'SplitItemName',
            splitProductDetail: 'SplitProductDetail',
            subscriptionType: 'SubscriptionType',
            tag: 'Tag',
            usage: 'Usage',
            usageUnit: 'UsageUnit',
            zone: 'Zone',
        };
    }
    static types() {
        return {
            adjustAmount: 'number',
            billingDate: 'string',
            billingItem: 'string',
            billingType: 'string',
            cashAmount: 'number',
            commodityCode: 'string',
            costUnit: 'string',
            currency: 'string',
            deductedByCashCoupons: 'number',
            deductedByCoupons: 'number',
            deductedByPrepaidCard: 'number',
            deductedByResourcePackage: 'string',
            instanceConfig: 'string',
            instanceID: 'string',
            instanceSpec: 'string',
            internetIP: 'string',
            intranetIP: 'string',
            invoiceDiscount: 'number',
            item: 'string',
            listPrice: 'string',
            listPriceUnit: 'string',
            nickName: 'string',
            outstandingAmount: 'number',
            ownerID: 'string',
            paymentAmount: 'number',
            pipCode: 'string',
            pretaxAmount: 'number',
            pretaxGrossAmount: 'number',
            productCode: 'string',
            productDetail: 'string',
            productName: 'string',
            productType: 'string',
            region: 'string',
            resourceGroup: 'string',
            servicePeriod: 'string',
            servicePeriodUnit: 'string',
            splitAccountID: 'string',
            splitAccountName: 'string',
            splitBillingCycle: 'string',
            splitCommodityCode: 'string',
            splitItemID: 'string',
            splitItemName: 'string',
            splitProductDetail: 'string',
            subscriptionType: 'string',
            tag: 'string',
            usage: 'string',
            usageUnit: 'string',
            zone: 'string',
        };
    }
}
exports.QuerySplitItemBillResponseBodyDataItemsItem = QuerySplitItemBillResponseBodyDataItemsItem;
class QuerySplitItemBillResponseBodyDataItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': QuerySplitItemBillResponseBodyDataItemsItem },
        };
    }
}
exports.QuerySplitItemBillResponseBodyDataItems = QuerySplitItemBillResponseBodyDataItems;
class QuerySplitItemBillResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountID: 'AccountID',
            accountName: 'AccountName',
            billingCycle: 'BillingCycle',
            items: 'Items',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accountID: 'string',
            accountName: 'string',
            billingCycle: 'string',
            items: QuerySplitItemBillResponseBodyDataItems,
            pageNum: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.QuerySplitItemBillResponseBodyData = QuerySplitItemBillResponseBodyData;
class QueryUserOmsDataResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            marker: 'Marker',
            omsData: 'OmsData',
        };
    }
    static types() {
        return {
            hostId: 'string',
            marker: 'string',
            omsData: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.QueryUserOmsDataResponseBodyData = QueryUserOmsDataResponseBodyData;
class RefundInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            hostId: 'string',
            orderId: 'number',
        };
    }
}
exports.RefundInstanceResponseBodyData = RefundInstanceResponseBodyData;
class ReleaseInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
            releaseResult: 'ReleaseResult',
        };
    }
    static types() {
        return {
            hostId: 'string',
            releaseResult: 'boolean',
        };
    }
}
exports.ReleaseInstanceResponseBodyData = ReleaseInstanceResponseBodyData;
class RelieveAccountRelationResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostId: 'HostId',
        };
    }
    static types() {
        return {
            hostId: 'string',
        };
    }
}
exports.RelieveAccountRelationResponseBodyData = RelieveAccountRelationResponseBodyData;
class RenewInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            orderId: 'string',
        };
    }
}
exports.RenewInstanceResponseBodyData = RenewInstanceResponseBodyData;
class RenewResourcePackageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            orderId: 'number',
        };
    }
}
exports.RenewResourcePackageResponseBodyData = RenewResourcePackageResponseBodyData;
class TagResourcesRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.TagResourcesRequestTag = TagResourcesRequestTag;
class UpgradeResourcePackageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            orderId: 'number',
        };
    }
}
exports.UpgradeResourcePackageResponseBodyData = UpgradeResourcePackageResponseBodyData;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "regional";
        this._endpointMap = {
            'cn-hangzhou': "business.aliyuncs.com",
            'cn-shanghai': "business.aliyuncs.com",
            'ap-southeast-1': "business.ap-southeast-1.aliyuncs.com",
            'ap-northeast-1': "business.ap-southeast-1.aliyuncs.com",
            'ap-northeast-2': "business.ap-southeast-1.aliyuncs.com",
            'ap-northeast-2-pop': "business.ap-southeast-1.aliyuncs.com",
            'ap-south-1': "business.ap-southeast-1.aliyuncs.com",
            'ap-southeast-2': "business.ap-southeast-1.aliyuncs.com",
            'ap-southeast-3': "business.ap-southeast-1.aliyuncs.com",
            'ap-southeast-5': "business.ap-southeast-1.aliyuncs.com",
            'cn-beijing': "business.aliyuncs.com",
            'cn-beijing-finance-1': "business.aliyuncs.com",
            'cn-beijing-finance-pop': "business.aliyuncs.com",
            'cn-beijing-gov-1': "business.aliyuncs.com",
            'cn-beijing-nu16-b01': "business.aliyuncs.com",
            'cn-chengdu': "business.aliyuncs.com",
            'cn-edge-1': "business.aliyuncs.com",
            'cn-fujian': "business.aliyuncs.com",
            'cn-haidian-cm12-c01': "business.aliyuncs.com",
            'cn-hangzhou-bj-b01': "business.aliyuncs.com",
            'cn-hangzhou-finance': "business.aliyuncs.com",
            'cn-hangzhou-internal-prod-1': "business.aliyuncs.com",
            'cn-hangzhou-internal-test-1': "business.aliyuncs.com",
            'cn-hangzhou-internal-test-2': "business.aliyuncs.com",
            'cn-hangzhou-internal-test-3': "business.aliyuncs.com",
            'cn-hangzhou-test-306': "business.aliyuncs.com",
            'cn-hongkong': "business.aliyuncs.com",
            'cn-hongkong-finance-pop': "business.aliyuncs.com",
            'cn-huhehaote': "business.aliyuncs.com",
            'cn-huhehaote-nebula-1': "business.aliyuncs.com",
            'cn-north-2-gov-1': "business.aliyuncs.com",
            'cn-qingdao': "business.aliyuncs.com",
            'cn-qingdao-nebula': "business.aliyuncs.com",
            'cn-shanghai-et15-b01': "business.aliyuncs.com",
            'cn-shanghai-et2-b01': "business.aliyuncs.com",
            'cn-shanghai-finance-1': "business.aliyuncs.com",
            'cn-shanghai-inner': "business.aliyuncs.com",
            'cn-shanghai-internal-test-1': "business.aliyuncs.com",
            'cn-shenzhen': "business.aliyuncs.com",
            'cn-shenzhen-finance-1': "business.aliyuncs.com",
            'cn-shenzhen-inner': "business.aliyuncs.com",
            'cn-shenzhen-st4-d01': "business.aliyuncs.com",
            'cn-shenzhen-su18-b01': "business.aliyuncs.com",
            'cn-wuhan': "business.aliyuncs.com",
            'cn-wulanchabu': "business.aliyuncs.com",
            'cn-yushanfang': "business.aliyuncs.com",
            'cn-zhangbei': "business.aliyuncs.com",
            'cn-zhangbei-na61-b01': "business.aliyuncs.com",
            'cn-zhangjiakou': "business.aliyuncs.com",
            'cn-zhangjiakou-na62-a01': "business.aliyuncs.com",
            'cn-zhengzhou-nebula-1': "business.aliyuncs.com",
            'eu-central-1': "business.ap-southeast-1.aliyuncs.com",
            'eu-west-1': "business.ap-southeast-1.aliyuncs.com",
            'eu-west-1-oxs': "business.ap-southeast-1.aliyuncs.com",
            'me-east-1': "business.ap-southeast-1.aliyuncs.com",
            'rus-west-1-pop': "business.ap-southeast-1.aliyuncs.com",
            'us-east-1': "business.ap-southeast-1.aliyuncs.com",
            'us-west-1': "business.ap-southeast-1.aliyuncs.com",
        };
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("bssopenapi", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    /**
      * 1\\. For more information about a financial relationship, see [Financial relationships](https://help.aliyun.com/document_detail/100376.html?spm=a2c4g.11186623.6.563.52a83908ypl4yE) or [Financial relationships](https://www.alibabacloud.com/help/en/doc-detail/116383.html). 2. If enterprise names used by the management account and a member for real-name verification are the same, you do not need to call an API operation for confirmation. Otherwise, you must call the ConfirmRelation operation for confirmation.
      *
      * @param request AddAccountRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return AddAccountRelationResponse
     */
    async addAccountRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.childNick)) {
            query["ChildNick"] = request.childNick;
        }
        if (!tea_util_1.default.isUnset(request.childUserId)) {
            query["ChildUserId"] = request.childUserId;
        }
        if (!tea_util_1.default.isUnset(request.parentUserId)) {
            query["ParentUserId"] = request.parentUserId;
        }
        if (!tea_util_1.default.isUnset(request.permissionCodes)) {
            query["PermissionCodes"] = request.permissionCodes;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["RelationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            query["RequestId"] = request.requestId;
        }
        if (!tea_util_1.default.isUnset(request.roleCodes)) {
            query["RoleCodes"] = request.roleCodes;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AddAccountRelation",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AddAccountRelationResponse({}));
    }
    /**
      * 1\\. For more information about a financial relationship, see [Financial relationships](https://help.aliyun.com/document_detail/100376.html?spm=a2c4g.11186623.6.563.52a83908ypl4yE) or [Financial relationships](https://www.alibabacloud.com/help/en/doc-detail/116383.html). 2. If enterprise names used by the management account and a member for real-name verification are the same, you do not need to call an API operation for confirmation. Otherwise, you must call the ConfirmRelation operation for confirmation.
      *
      * @param request AddAccountRelationRequest
      * @return AddAccountRelationResponse
     */
    async addAccountRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.addAccountRelationWithOptions(request, runtime);
    }
    async allocateCostUnitResourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fromUnitId)) {
            query["FromUnitId"] = request.fromUnitId;
        }
        if (!tea_util_1.default.isUnset(request.fromUnitUserId)) {
            query["FromUnitUserId"] = request.fromUnitUserId;
        }
        if (!tea_util_1.default.isUnset(request.resourceInstanceList)) {
            query["ResourceInstanceList"] = request.resourceInstanceList;
        }
        if (!tea_util_1.default.isUnset(request.toUnitId)) {
            query["ToUnitId"] = request.toUnitId;
        }
        if (!tea_util_1.default.isUnset(request.toUnitUserId)) {
            query["ToUnitUserId"] = request.toUnitUserId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AllocateCostUnitResource",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AllocateCostUnitResourceResponse({}));
    }
    async allocateCostUnitResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.allocateCostUnitResourceWithOptions(request, runtime);
    }
    async applyInvoiceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.addressId)) {
            query["AddressId"] = request.addressId;
        }
        if (!tea_util_1.default.isUnset(request.applyUserNick)) {
            query["ApplyUserNick"] = request.applyUserNick;
        }
        if (!tea_util_1.default.isUnset(request.customerId)) {
            query["CustomerId"] = request.customerId;
        }
        if (!tea_util_1.default.isUnset(request.invoiceAmount)) {
            query["InvoiceAmount"] = request.invoiceAmount;
        }
        if (!tea_util_1.default.isUnset(request.invoiceByAmount)) {
            query["InvoiceByAmount"] = request.invoiceByAmount;
        }
        if (!tea_util_1.default.isUnset(request.invoicingType)) {
            query["InvoicingType"] = request.invoicingType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.processWay)) {
            query["ProcessWay"] = request.processWay;
        }
        if (!tea_util_1.default.isUnset(request.selectedIds)) {
            query["SelectedIds"] = request.selectedIds;
        }
        if (!tea_util_1.default.isUnset(request.userRemark)) {
            query["UserRemark"] = request.userRemark;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ApplyInvoice",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ApplyInvoiceResponse({}));
    }
    async applyInvoice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.applyInvoiceWithOptions(request, runtime);
    }
    async cancelOrderWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelOrder",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelOrderResponse({}));
    }
    async cancelOrder(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelOrderWithOptions(request, runtime);
    }
    async changeResellerConsumeAmountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.adjustType)) {
            query["AdjustType"] = request.adjustType;
        }
        if (!tea_util_1.default.isUnset(request.amount)) {
            query["Amount"] = request.amount;
        }
        if (!tea_util_1.default.isUnset(request.businessType)) {
            query["BusinessType"] = request.businessType;
        }
        if (!tea_util_1.default.isUnset(request.currency)) {
            query["Currency"] = request.currency;
        }
        if (!tea_util_1.default.isUnset(request.extendMap)) {
            query["ExtendMap"] = request.extendMap;
        }
        if (!tea_util_1.default.isUnset(request.outBizId)) {
            query["OutBizId"] = request.outBizId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            query["Source"] = request.source;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ChangeResellerConsumeAmount",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ChangeResellerConsumeAmountResponse({}));
    }
    async changeResellerConsumeAmount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.changeResellerConsumeAmountWithOptions(request, runtime);
    }
    /**
      * 1\\. A member needs to confirm an invitation only if a financial management relationship is established between the management account and the member and enterprise names used by the management account and the member for real-name verification are different. 2. The permissions to be confirmed must be the same as those granted to the member when the management account initiates the invitation.
      *
      * @param request ConfirmRelationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ConfirmRelationResponse
     */
    async confirmRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.childUserId)) {
            query["ChildUserId"] = request.childUserId;
        }
        if (!tea_util_1.default.isUnset(request.confirmCode)) {
            query["ConfirmCode"] = request.confirmCode;
        }
        if (!tea_util_1.default.isUnset(request.parentUserId)) {
            query["ParentUserId"] = request.parentUserId;
        }
        if (!tea_util_1.default.isUnset(request.permissionCodes)) {
            query["PermissionCodes"] = request.permissionCodes;
        }
        if (!tea_util_1.default.isUnset(request.relationId)) {
            query["RelationId"] = request.relationId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["RelationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            query["RequestId"] = request.requestId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ConfirmRelation",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ConfirmRelationResponse({}));
    }
    /**
      * 1\\. A member needs to confirm an invitation only if a financial management relationship is established between the management account and the member and enterprise names used by the management account and the member for real-name verification are different. 2. The permissions to be confirmed must be the same as those granted to the member when the management account initiates the invitation.
      *
      * @param request ConfirmRelationRequest
      * @return ConfirmRelationResponse
     */
    async confirmRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.confirmRelationWithOptions(request, runtime);
    }
    async convertChargeTypeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ConvertChargeType",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ConvertChargeTypeResponse({}));
    }
    async convertChargeType(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.convertChargeTypeWithOptions(request, runtime);
    }
    /**
      * You can call this operation to create an account so as to establish a master-member financial relationship.
      *
      * @param request CreateAgAccountRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateAgAccountResponse
     */
    async createAgAccountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountAttr)) {
            query["AccountAttr"] = request.accountAttr;
        }
        if (!tea_util_1.default.isUnset(request.cityName)) {
            query["CityName"] = request.cityName;
        }
        if (!tea_util_1.default.isUnset(request.enterpriseName)) {
            query["EnterpriseName"] = request.enterpriseName;
        }
        if (!tea_util_1.default.isUnset(request.firstName)) {
            query["FirstName"] = request.firstName;
        }
        if (!tea_util_1.default.isUnset(request.lastName)) {
            query["LastName"] = request.lastName;
        }
        if (!tea_util_1.default.isUnset(request.loginEmail)) {
            query["LoginEmail"] = request.loginEmail;
        }
        if (!tea_util_1.default.isUnset(request.nationCode)) {
            query["NationCode"] = request.nationCode;
        }
        if (!tea_util_1.default.isUnset(request.postcode)) {
            query["Postcode"] = request.postcode;
        }
        if (!tea_util_1.default.isUnset(request.provinceName)) {
            query["ProvinceName"] = request.provinceName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateAgAccount",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateAgAccountResponse({}));
    }
    /**
      * You can call this operation to create an account so as to establish a master-member financial relationship.
      *
      * @param request CreateAgAccountRequest
      * @return CreateAgAccountResponse
     */
    async createAgAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createAgAccountWithOptions(request, runtime);
    }
    async createCostUnitWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unitEntityList)) {
            query["UnitEntityList"] = request.unitEntityList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateCostUnit",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateCostUnitResponse({}));
    }
    async createCostUnit(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createCostUnitWithOptions(request, runtime);
    }
    async createInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.logistics)) {
            query["Logistics"] = request.logistics;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameter)) {
            query["Parameter"] = request.parameter;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.renewPeriod)) {
            query["RenewPeriod"] = request.renewPeriod;
        }
        if (!tea_util_1.default.isUnset(request.renewalStatus)) {
            query["RenewalStatus"] = request.renewalStatus;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateInstanceResponse({}));
    }
    async createInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createInstanceWithOptions(request, runtime);
    }
    async createResellerUserQuotaWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.amount)) {
            query["Amount"] = request.amount;
        }
        if (!tea_util_1.default.isUnset(request.currency)) {
            query["Currency"] = request.currency;
        }
        if (!tea_util_1.default.isUnset(request.outBizId)) {
            query["OutBizId"] = request.outBizId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateResellerUserQuota",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateResellerUserQuotaResponse({}));
    }
    async createResellerUserQuota(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createResellerUserQuotaWithOptions(request, runtime);
    }
    async createResourcePackageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.duration)) {
            query["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.effectiveDate)) {
            query["EffectiveDate"] = request.effectiveDate;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.packageType)) {
            query["PackageType"] = request.packageType;
        }
        if (!tea_util_1.default.isUnset(request.pricingCycle)) {
            query["PricingCycle"] = request.pricingCycle;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.specification)) {
            query["Specification"] = request.specification;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateResourcePackage",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateResourcePackageResponse({}));
    }
    async createResourcePackage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createResourcePackageWithOptions(request, runtime);
    }
    async createSavingsPlansInstanceWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateSavingsPlansInstanceShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.extendMap)) {
            request.extendMapShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.extendMap, "ExtendMap", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.duration)) {
            query["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.effectiveDate)) {
            query["EffectiveDate"] = request.effectiveDate;
        }
        if (!tea_util_1.default.isUnset(request.extendMapShrink)) {
            query["ExtendMap"] = request.extendMapShrink;
        }
        if (!tea_util_1.default.isUnset(request.payMode)) {
            query["PayMode"] = request.payMode;
        }
        if (!tea_util_1.default.isUnset(request.poolValue)) {
            query["PoolValue"] = request.poolValue;
        }
        if (!tea_util_1.default.isUnset(request.pricingCycle)) {
            query["PricingCycle"] = request.pricingCycle;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.specType)) {
            query["SpecType"] = request.specType;
        }
        if (!tea_util_1.default.isUnset(request.specification)) {
            query["Specification"] = request.specification;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateSavingsPlansInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSavingsPlansInstanceResponse({}));
    }
    async createSavingsPlansInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSavingsPlansInstanceWithOptions(request, runtime);
    }
    async deleteCostUnitWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerUid)) {
            query["OwnerUid"] = request.ownerUid;
        }
        if (!tea_util_1.default.isUnset(request.unitId)) {
            query["UnitId"] = request.unitId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteCostUnit",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteCostUnitResponse({}));
    }
    async deleteCostUnit(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteCostUnitWithOptions(request, runtime);
    }
    /**
      * This operation is in beta testing and is only available for specific users in the whitelist. Excessive calls may result in performance issues. For example, the response times out.
      *
      * @param request DescribeCostBudgetsSummaryRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCostBudgetsSummaryResponse
     */
    async describeCostBudgetsSummaryWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.budgetName)) {
            query["BudgetName"] = request.budgetName;
        }
        if (!tea_util_1.default.isUnset(request.budgetStatus)) {
            query["BudgetStatus"] = request.budgetStatus;
        }
        if (!tea_util_1.default.isUnset(request.budgetType)) {
            query["BudgetType"] = request.budgetType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCostBudgetsSummary",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCostBudgetsSummaryResponse({}));
    }
    /**
      * This operation is in beta testing and is only available for specific users in the whitelist. Excessive calls may result in performance issues. For example, the response times out.
      *
      * @param request DescribeCostBudgetsSummaryRequest
      * @return DescribeCostBudgetsSummaryResponse
     */
    async describeCostBudgetsSummary(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCostBudgetsSummaryWithOptions(request, runtime);
    }
    /**
      * You can view and export the allocated costs of the current month after 10:00 on the fourth day of the next month. The allocated costs of a single allocation month may involve orders or bills in different billing cycles. If a historical allocated amount is incorrect, the historical allocated costs need to be adjusted. As a result, the allocated costs displayed for a single allocation month may be different at different time points.
      *
      * @param request DescribeInstanceAmortizedCostByAmortizationPeriodRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeInstanceAmortizedCostByAmortizationPeriodResponse
     */
    async describeInstanceAmortizedCostByAmortizationPeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.billOwnerIdList)) {
            body["BillOwnerIdList"] = request.billOwnerIdList;
        }
        if (!tea_util_1.default.isUnset(request.billUserIdList)) {
            body["BillUserIdList"] = request.billUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            body["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.consumePeriodFilter)) {
            body["ConsumePeriodFilter"] = request.consumePeriodFilter;
        }
        if (!tea_util_1.default.isUnset(request.costUnitCode)) {
            body["CostUnitCode"] = request.costUnitCode;
        }
        if (!tea_util_1.default.isUnset(request.instanceIdList)) {
            body["InstanceIdList"] = request.instanceIdList;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            body["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productDetail)) {
            body["ProductDetail"] = request.productDetail;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            body["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceAmortizedCostByAmortizationPeriod",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceAmortizedCostByAmortizationPeriodResponse({}));
    }
    /**
      * You can view and export the allocated costs of the current month after 10:00 on the fourth day of the next month. The allocated costs of a single allocation month may involve orders or bills in different billing cycles. If a historical allocated amount is incorrect, the historical allocated costs need to be adjusted. As a result, the allocated costs displayed for a single allocation month may be different at different time points.
      *
      * @param request DescribeInstanceAmortizedCostByAmortizationPeriodRequest
      * @return DescribeInstanceAmortizedCostByAmortizationPeriodResponse
     */
    async describeInstanceAmortizedCostByAmortizationPeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceAmortizedCostByAmortizationPeriodWithOptions(request, runtime);
    }
    async describeInstanceAmortizedCostByAmortizationPeriodDateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.amortizationDateEnd)) {
            body["AmortizationDateEnd"] = request.amortizationDateEnd;
        }
        if (!tea_util_1.default.isUnset(request.amortizationDateStart)) {
            body["AmortizationDateStart"] = request.amortizationDateStart;
        }
        if (!tea_util_1.default.isUnset(request.billOwnerIdList)) {
            body["BillOwnerIdList"] = request.billOwnerIdList;
        }
        if (!tea_util_1.default.isUnset(request.billUserIdList)) {
            body["BillUserIdList"] = request.billUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            body["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.costUnitCode)) {
            body["CostUnitCode"] = request.costUnitCode;
        }
        if (!tea_util_1.default.isUnset(request.instanceIdList)) {
            body["InstanceIdList"] = request.instanceIdList;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            body["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productDetail)) {
            body["ProductDetail"] = request.productDetail;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            body["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceAmortizedCostByAmortizationPeriodDate",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceAmortizedCostByAmortizationPeriodDateResponse({}));
    }
    async describeInstanceAmortizedCostByAmortizationPeriodDate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceAmortizedCostByAmortizationPeriodDateWithOptions(request, runtime);
    }
    async describeInstanceAmortizedCostByConsumePeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.amortizationPeriodFilter)) {
            body["AmortizationPeriodFilter"] = request.amortizationPeriodFilter;
        }
        if (!tea_util_1.default.isUnset(request.billOwnerIdList)) {
            body["BillOwnerIdList"] = request.billOwnerIdList;
        }
        if (!tea_util_1.default.isUnset(request.billUserIdList)) {
            body["BillUserIdList"] = request.billUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            body["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.costUnitCode)) {
            body["CostUnitCode"] = request.costUnitCode;
        }
        if (!tea_util_1.default.isUnset(request.instanceIdList)) {
            body["InstanceIdList"] = request.instanceIdList;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            body["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productDetail)) {
            body["ProductDetail"] = request.productDetail;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            body["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceAmortizedCostByConsumePeriod",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceAmortizedCostByConsumePeriodResponse({}));
    }
    async describeInstanceAmortizedCostByConsumePeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceAmortizedCostByConsumePeriodWithOptions(request, runtime);
    }
    /**
      * *   Instance bills are generated after the total bill is split. In most cases, the instance bills do not include data generated on the last day of the specified billing cycle.
      * *   The instance information may change during the billing cycle. The instance configurations and types in monthly bills are subject to the point in time when you query bills. For more information, see the corresponding bill details.
      * *   You can query data generated after June 2020 for Cloud Communications services. You can query data generated after November 2020 for Alibaba Cloud Domains.
      *
      * @param request DescribeInstanceBillRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeInstanceBillResponse
     */
    async describeInstanceBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.billingDate)) {
            query["BillingDate"] = request.billingDate;
        }
        if (!tea_util_1.default.isUnset(request.granularity)) {
            query["Granularity"] = request.granularity;
        }
        if (!tea_util_1.default.isUnset(request.instanceID)) {
            query["InstanceID"] = request.instanceID;
        }
        if (!tea_util_1.default.isUnset(request.isBillingItem)) {
            query["IsBillingItem"] = request.isBillingItem;
        }
        if (!tea_util_1.default.isUnset(request.isHideZeroCharge)) {
            query["IsHideZeroCharge"] = request.isHideZeroCharge;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceBillResponse({}));
    }
    /**
      * *   Instance bills are generated after the total bill is split. In most cases, the instance bills do not include data generated on the last day of the specified billing cycle.
      * *   The instance information may change during the billing cycle. The instance configurations and types in monthly bills are subject to the point in time when you query bills. For more information, see the corresponding bill details.
      * *   You can query data generated after June 2020 for Cloud Communications services. You can query data generated after November 2020 for Alibaba Cloud Domains.
      *
      * @param request DescribeInstanceBillRequest
      * @return DescribeInstanceBillResponse
     */
    async describeInstanceBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceBillWithOptions(request, runtime);
    }
    async describePricingModuleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribePricingModule",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePricingModuleResponse({}));
    }
    async describePricingModule(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describePricingModuleWithOptions(request, runtime);
    }
    /**
      * You can view and export the allocated costs of the current month after 10:00 on the fourth day of the next month. The allocated costs of a single allocation month may involve orders or bills in different billing cycles. If a historical allocated amount is incorrect, the historical allocated costs need to be adjusted. As a result, the allocated costs displayed for a single allocation month may be different at different time points.
      *
      * @param request DescribeProductAmortizedCostByAmortizationPeriodRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeProductAmortizedCostByAmortizationPeriodResponse
     */
    async describeProductAmortizedCostByAmortizationPeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.billOwnerIdList)) {
            body["BillOwnerIdList"] = request.billOwnerIdList;
        }
        if (!tea_util_1.default.isUnset(request.billUserIdList)) {
            body["BillUserIdList"] = request.billUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            body["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.consumePeriodFilter)) {
            body["ConsumePeriodFilter"] = request.consumePeriodFilter;
        }
        if (!tea_util_1.default.isUnset(request.costUnitCode)) {
            body["CostUnitCode"] = request.costUnitCode;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            body["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productDetail)) {
            body["ProductDetail"] = request.productDetail;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            body["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeProductAmortizedCostByAmortizationPeriod",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeProductAmortizedCostByAmortizationPeriodResponse({}));
    }
    /**
      * You can view and export the allocated costs of the current month after 10:00 on the fourth day of the next month. The allocated costs of a single allocation month may involve orders or bills in different billing cycles. If a historical allocated amount is incorrect, the historical allocated costs need to be adjusted. As a result, the allocated costs displayed for a single allocation month may be different at different time points.
      *
      * @param request DescribeProductAmortizedCostByAmortizationPeriodRequest
      * @return DescribeProductAmortizedCostByAmortizationPeriodResponse
     */
    async describeProductAmortizedCostByAmortizationPeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeProductAmortizedCostByAmortizationPeriodWithOptions(request, runtime);
    }
    async describeProductAmortizedCostByConsumePeriodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.amortizationPeriodFilter)) {
            body["AmortizationPeriodFilter"] = request.amortizationPeriodFilter;
        }
        if (!tea_util_1.default.isUnset(request.billOwnerIdList)) {
            body["BillOwnerIdList"] = request.billOwnerIdList;
        }
        if (!tea_util_1.default.isUnset(request.billUserIdList)) {
            body["BillUserIdList"] = request.billUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            body["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.costUnitCode)) {
            body["CostUnitCode"] = request.costUnitCode;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            body["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productDetail)) {
            body["ProductDetail"] = request.productDetail;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            body["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeProductAmortizedCostByConsumePeriod",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeProductAmortizedCostByConsumePeriodResponse({}));
    }
    async describeProductAmortizedCostByConsumePeriod(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeProductAmortizedCostByConsumePeriodWithOptions(request, runtime);
    }
    /**
      * The amount of the resources deducted from a deduction plan.
      *
      * @param request DescribeResourceCoverageDetailRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeResourceCoverageDetailResponse
     */
    async describeResourceCoverageDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourceCoverageDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourceCoverageDetailResponse({}));
    }
    /**
      * The amount of the resources deducted from a deduction plan.
      *
      * @param request DescribeResourceCoverageDetailRequest
      * @return DescribeResourceCoverageDetailResponse
     */
    async describeResourceCoverageDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourceCoverageDetailWithOptions(request, runtime);
    }
    /**
      * Indicates whether the operation was successful.
      *
      * @param request DescribeResourceCoverageTotalRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeResourceCoverageTotalResponse
     */
    async describeResourceCoverageTotalWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourceCoverageTotal",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourceCoverageTotalResponse({}));
    }
    /**
      * Indicates whether the operation was successful.
      *
      * @param request DescribeResourceCoverageTotalRequest
      * @return DescribeResourceCoverageTotalResponse
     */
    async describeResourceCoverageTotal(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourceCoverageTotalWithOptions(request, runtime);
    }
    async describeResourcePackageProductWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourcePackageProduct",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourcePackageProductResponse({}));
    }
    async describeResourcePackageProduct(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourcePackageProductWithOptions(request, runtime);
    }
    async describeResourceUsageDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourceUsageDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourceUsageDetailResponse({}));
    }
    async describeResourceUsageDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourceUsageDetailWithOptions(request, runtime);
    }
    async describeResourceUsageTotalWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourceUsageTotal",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourceUsageTotalResponse({}));
    }
    async describeResourceUsageTotal(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourceUsageTotalWithOptions(request, runtime);
    }
    async describeSavingsPlansCoverageDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            query["Token"] = request.token;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSavingsPlansCoverageDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSavingsPlansCoverageDetailResponse({}));
    }
    async describeSavingsPlansCoverageDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSavingsPlansCoverageDetailWithOptions(request, runtime);
    }
    async describeSavingsPlansCoverageTotalWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSavingsPlansCoverageTotal",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSavingsPlansCoverageTotalResponse({}));
    }
    async describeSavingsPlansCoverageTotal(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSavingsPlansCoverageTotalWithOptions(request, runtime);
    }
    async describeSavingsPlansUsageDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            query["Token"] = request.token;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSavingsPlansUsageDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSavingsPlansUsageDetailResponse({}));
    }
    async describeSavingsPlansUsageDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSavingsPlansUsageDetailWithOptions(request, runtime);
    }
    async describeSavingsPlansUsageTotalWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.endPeriod)) {
            query["EndPeriod"] = request.endPeriod;
        }
        if (!tea_util_1.default.isUnset(request.periodType)) {
            query["PeriodType"] = request.periodType;
        }
        if (!tea_util_1.default.isUnset(request.startPeriod)) {
            query["StartPeriod"] = request.startPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSavingsPlansUsageTotal",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSavingsPlansUsageTotalResponse({}));
    }
    async describeSavingsPlansUsageTotal(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSavingsPlansUsageTotalWithOptions(request, runtime);
    }
    /**
      * The code of the service.
      *
      * @param request DescribeSplitItemBillRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSplitItemBillResponse
     */
    async describeSplitItemBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.billingDate)) {
            query["BillingDate"] = request.billingDate;
        }
        if (!tea_util_1.default.isUnset(request.granularity)) {
            query["Granularity"] = request.granularity;
        }
        if (!tea_util_1.default.isUnset(request.instanceID)) {
            query["InstanceID"] = request.instanceID;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.splitItemID)) {
            query["SplitItemID"] = request.splitItemID;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        if (!tea_util_1.default.isUnset(request.tagFilter)) {
            query["TagFilter"] = request.tagFilter;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSplitItemBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSplitItemBillResponse({}));
    }
    /**
      * The code of the service.
      *
      * @param request DescribeSplitItemBillRequest
      * @return DescribeSplitItemBillResponse
     */
    async describeSplitItemBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSplitItemBillWithOptions(request, runtime);
    }
    async enableBillGenerationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EnableBillGeneration",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EnableBillGenerationResponse({}));
    }
    async enableBillGeneration(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.enableBillGenerationWithOptions(request, runtime);
    }
    async getAccountRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAccountRelation",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAccountRelationResponse({}));
    }
    async getAccountRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getAccountRelationWithOptions(request, runtime);
    }
    async getCustomerAccountInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCustomerAccountInfo",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetCustomerAccountInfoResponse({}));
    }
    async getCustomerAccountInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getCustomerAccountInfoWithOptions(request, runtime);
    }
    /**
      * The ID of the customer.
      *
      * @param request GetCustomerListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetCustomerListResponse
     */
    async getCustomerListWithOptions(runtime) {
        let req = new $OpenApi.OpenApiRequest({});
        let params = new $OpenApi.Params({
            action: "GetCustomerList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetCustomerListResponse({}));
    }
    /**
      * The ID of the customer.
      *
      * @return GetCustomerListResponse
     */
    async getCustomerList() {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getCustomerListWithOptions(runtime);
    }
    async getOrderDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetOrderDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetOrderDetailResponse({}));
    }
    async getOrderDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getOrderDetailWithOptions(request, runtime);
    }
    /**
      * ### Usage notes
      * 1.  Call the QueryProductList operation to obtain the code of the service. For more information, see [QueryProductList](~~95984~~).
      * 2.  Call the DescribePricingModule operation to obtain the configuration parameters of the service. For more information, see [DescribePricingModule](~~96469~~).
      * 3.  Call the GetPayAsYouGoPrice operation to obtain the pay-as-you-go price of the service based on the returned configuration parameters.
      *
      * @param request GetPayAsYouGoPriceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetPayAsYouGoPriceResponse
     */
    async getPayAsYouGoPriceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.moduleList)) {
            query["ModuleList"] = request.moduleList;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetPayAsYouGoPrice",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetPayAsYouGoPriceResponse({}));
    }
    /**
      * ### Usage notes
      * 1.  Call the QueryProductList operation to obtain the code of the service. For more information, see [QueryProductList](~~95984~~).
      * 2.  Call the DescribePricingModule operation to obtain the configuration parameters of the service. For more information, see [DescribePricingModule](~~96469~~).
      * 3.  Call the GetPayAsYouGoPrice operation to obtain the pay-as-you-go price of the service based on the returned configuration parameters.
      *
      * @param request GetPayAsYouGoPriceRequest
      * @return GetPayAsYouGoPriceResponse
     */
    async getPayAsYouGoPrice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getPayAsYouGoPriceWithOptions(request, runtime);
    }
    async getResourcePackagePriceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.duration)) {
            query["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.effectiveDate)) {
            query["EffectiveDate"] = request.effectiveDate;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.packageType)) {
            query["PackageType"] = request.packageType;
        }
        if (!tea_util_1.default.isUnset(request.pricingCycle)) {
            query["PricingCycle"] = request.pricingCycle;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.specification)) {
            query["Specification"] = request.specification;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetResourcePackagePrice",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetResourcePackagePriceResponse({}));
    }
    async getResourcePackagePrice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getResourcePackagePriceWithOptions(request, runtime);
    }
    /**
      * 1.  Call the QueryProductList operation to obtain the code of the service. For more information, see [QueryProductList](~~95984~~).
      * 2.  Call the DescribePricingModule operation to obtain the configuration parameters of the service. For more information, see [DescribePricingModule](~~96469~~).
      * 3.  Call the GetSubscriptionPrice operation to obtain the pricing of the service based on the returned configuration parameters.
      *
      * @param request GetSubscriptionPriceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetSubscriptionPriceResponse
     */
    async getSubscriptionPriceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.moduleList)) {
            query["ModuleList"] = request.moduleList;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.quantity)) {
            query["Quantity"] = request.quantity;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.servicePeriodQuantity)) {
            query["ServicePeriodQuantity"] = request.servicePeriodQuantity;
        }
        if (!tea_util_1.default.isUnset(request.servicePeriodUnit)) {
            query["ServicePeriodUnit"] = request.servicePeriodUnit;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSubscriptionPrice",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetSubscriptionPriceResponse({}));
    }
    /**
      * 1.  Call the QueryProductList operation to obtain the code of the service. For more information, see [QueryProductList](~~95984~~).
      * 2.  Call the DescribePricingModule operation to obtain the configuration parameters of the service. For more information, see [DescribePricingModule](~~96469~~).
      * 3.  Call the GetSubscriptionPrice operation to obtain the pricing of the service based on the returned configuration parameters.
      *
      * @param request GetSubscriptionPriceRequest
      * @return GetSubscriptionPriceResponse
     */
    async getSubscriptionPrice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getSubscriptionPriceWithOptions(request, runtime);
    }
    /**
      * 1.  **Check the information about unsubscription and confirm the unsubscription terms and refundable amount. The resource that is unsubscribed cannot be restored.**
      * 2.  Refunds are applicable only for the actual paid amount. Vouchers used for the purchase are non-refundable.
      * 3.  For more information, see [Rules for unsubscribing from resources](https://help.aliyun.com/knowledge_detail/116043.html?spm=a2c81.e1d666e.app.2.62ae11271Kd6iM).
      *
      * @param request InquiryPriceRefundInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return InquiryPriceRefundInstanceResponse
     */
    async inquiryPriceRefundInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "InquiryPriceRefundInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new InquiryPriceRefundInstanceResponse({}));
    }
    /**
      * 1.  **Check the information about unsubscription and confirm the unsubscription terms and refundable amount. The resource that is unsubscribed cannot be restored.**
      * 2.  Refunds are applicable only for the actual paid amount. Vouchers used for the purchase are non-refundable.
      * 3.  For more information, see [Rules for unsubscribing from resources](https://help.aliyun.com/knowledge_detail/116043.html?spm=a2c81.e1d666e.app.2.62ae11271Kd6iM).
      *
      * @param request InquiryPriceRefundInstanceRequest
      * @return InquiryPriceRefundInstanceResponse
     */
    async inquiryPriceRefundInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.inquiryPriceRefundInstanceWithOptions(request, runtime);
    }
    async modifyAccountRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.childNick)) {
            query["ChildNick"] = request.childNick;
        }
        if (!tea_util_1.default.isUnset(request.childUserId)) {
            query["ChildUserId"] = request.childUserId;
        }
        if (!tea_util_1.default.isUnset(request.parentUserId)) {
            query["ParentUserId"] = request.parentUserId;
        }
        if (!tea_util_1.default.isUnset(request.permissionCodes)) {
            query["PermissionCodes"] = request.permissionCodes;
        }
        if (!tea_util_1.default.isUnset(request.relationId)) {
            query["RelationId"] = request.relationId;
        }
        if (!tea_util_1.default.isUnset(request.relationOperation)) {
            query["RelationOperation"] = request.relationOperation;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["RelationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            query["RequestId"] = request.requestId;
        }
        if (!tea_util_1.default.isUnset(request.roleCodes)) {
            query["RoleCodes"] = request.roleCodes;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyAccountRelation",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyAccountRelationResponse({}));
    }
    async modifyAccountRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyAccountRelationWithOptions(request, runtime);
    }
    async modifyCostUnitWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unitEntityList)) {
            query["UnitEntityList"] = request.unitEntityList;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyCostUnit",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyCostUnitResponse({}));
    }
    async modifyCostUnit(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyCostUnitWithOptions(request, runtime);
    }
    async modifyInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.modifyType)) {
            query["ModifyType"] = request.modifyType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameter)) {
            query["Parameter"] = request.parameter;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyInstanceResponse({}));
    }
    async modifyInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyInstanceWithOptions(request, runtime);
    }
    async queryAccountBalanceWithOptions(runtime) {
        let req = new $OpenApi.OpenApiRequest({});
        let params = new $OpenApi.Params({
            action: "QueryAccountBalance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryAccountBalanceResponse({}));
    }
    async queryAccountBalance() {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryAccountBalanceWithOptions(runtime);
    }
    /**
      * ##
      * Before you call this operation, take note of the following items:
      * *   Account bills are summarized based on instance bills. In most cases, the account bills do not include the data generated on the last day of the specified period.
      * *   You can query the data generated in June 2020 or later for Cloud Communications services. However, the query results do not include the data of Alibaba Cloud Domains.
      *
      * @param request QueryAccountBillRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryAccountBillResponse
     */
    async queryAccountBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.billingDate)) {
            query["BillingDate"] = request.billingDate;
        }
        if (!tea_util_1.default.isUnset(request.granularity)) {
            query["Granularity"] = request.granularity;
        }
        if (!tea_util_1.default.isUnset(request.isGroupByProduct)) {
            query["IsGroupByProduct"] = request.isGroupByProduct;
        }
        if (!tea_util_1.default.isUnset(request.ownerID)) {
            query["OwnerID"] = request.ownerID;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryAccountBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryAccountBillResponse({}));
    }
    /**
      * ##
      * Before you call this operation, take note of the following items:
      * *   Account bills are summarized based on instance bills. In most cases, the account bills do not include the data generated on the last day of the specified period.
      * *   You can query the data generated in June 2020 or later for Cloud Communications services. However, the query results do not include the data of Alibaba Cloud Domains.
      *
      * @param request QueryAccountBillRequest
      * @return QueryAccountBillResponse
     */
    async queryAccountBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryAccountBillWithOptions(request, runtime);
    }
    async queryAccountTransactionDetailsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.createTimeEnd)) {
            query["CreateTimeEnd"] = request.createTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.createTimeStart)) {
            query["CreateTimeStart"] = request.createTimeStart;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.recordID)) {
            query["RecordID"] = request.recordID;
        }
        if (!tea_util_1.default.isUnset(request.transactionChannel)) {
            query["TransactionChannel"] = request.transactionChannel;
        }
        if (!tea_util_1.default.isUnset(request.transactionChannelSN)) {
            query["TransactionChannelSN"] = request.transactionChannelSN;
        }
        if (!tea_util_1.default.isUnset(request.transactionNumber)) {
            query["TransactionNumber"] = request.transactionNumber;
        }
        if (!tea_util_1.default.isUnset(request.transactionType)) {
            query["TransactionType"] = request.transactionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryAccountTransactionDetails",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryAccountTransactionDetailsResponse({}));
    }
    async queryAccountTransactionDetails(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryAccountTransactionDetailsWithOptions(request, runtime);
    }
    async queryAccountTransactionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.createTimeEnd)) {
            query["CreateTimeEnd"] = request.createTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.createTimeStart)) {
            query["CreateTimeStart"] = request.createTimeStart;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.recordID)) {
            query["RecordID"] = request.recordID;
        }
        if (!tea_util_1.default.isUnset(request.transactionChannel)) {
            query["TransactionChannel"] = request.transactionChannel;
        }
        if (!tea_util_1.default.isUnset(request.transactionChannelSN)) {
            query["TransactionChannelSN"] = request.transactionChannelSN;
        }
        if (!tea_util_1.default.isUnset(request.transactionFlow)) {
            query["TransactionFlow"] = request.transactionFlow;
        }
        if (!tea_util_1.default.isUnset(request.transactionNumber)) {
            query["TransactionNumber"] = request.transactionNumber;
        }
        if (!tea_util_1.default.isUnset(request.transactionType)) {
            query["TransactionType"] = request.transactionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryAccountTransactions",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryAccountTransactionsResponse({}));
    }
    async queryAccountTransactions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryAccountTransactionsWithOptions(request, runtime);
    }
    async queryAvailableInstancesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.createTimeEnd)) {
            query["CreateTimeEnd"] = request.createTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.createTimeStart)) {
            query["CreateTimeStart"] = request.createTimeStart;
        }
        if (!tea_util_1.default.isUnset(request.endTimeEnd)) {
            query["EndTimeEnd"] = request.endTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.endTimeStart)) {
            query["EndTimeStart"] = request.endTimeStart;
        }
        if (!tea_util_1.default.isUnset(request.instanceIDs)) {
            query["InstanceIDs"] = request.instanceIDs;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.renewStatus)) {
            query["RenewStatus"] = request.renewStatus;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryAvailableInstances",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryAvailableInstancesResponse({}));
    }
    async queryAvailableInstances(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryAvailableInstancesWithOptions(request, runtime);
    }
    async queryBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.isDisplayLocalCurrency)) {
            query["IsDisplayLocalCurrency"] = request.isDisplayLocalCurrency;
        }
        if (!tea_util_1.default.isUnset(request.isHideZeroCharge)) {
            query["IsHideZeroCharge"] = request.isHideZeroCharge;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryBillResponse({}));
    }
    async queryBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryBillWithOptions(request, runtime);
    }
    async queryBillOverviewWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryBillOverview",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryBillOverviewResponse({}));
    }
    async queryBillOverview(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryBillOverviewWithOptions(request, runtime);
    }
    async queryBillToOSSSubscriptionWithOptions(runtime) {
        let req = new $OpenApi.OpenApiRequest({});
        let params = new $OpenApi.Params({
            action: "QueryBillToOSSSubscription",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryBillToOSSSubscriptionResponse({}));
    }
    async queryBillToOSSSubscription() {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryBillToOSSSubscriptionWithOptions(runtime);
    }
    async queryCashCouponsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.effectiveOrNot)) {
            query["EffectiveOrNot"] = request.effectiveOrNot;
        }
        if (!tea_util_1.default.isUnset(request.expiryTimeEnd)) {
            query["ExpiryTimeEnd"] = request.expiryTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.expiryTimeStart)) {
            query["ExpiryTimeStart"] = request.expiryTimeStart;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCashCoupons",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryCashCouponsResponse({}));
    }
    async queryCashCoupons(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryCashCouponsWithOptions(request, runtime);
    }
    /**
      * You can call this operation to query the information about a service based on the service code.
      *
      * @param request QueryCommodityListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryCommodityListResponse
     */
    async queryCommodityListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCommodityList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryCommodityListResponse({}));
    }
    /**
      * You can call this operation to query the information about a service based on the service code.
      *
      * @param request QueryCommodityListRequest
      * @return QueryCommodityListResponse
     */
    async queryCommodityList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryCommodityListWithOptions(request, runtime);
    }
    async queryCostUnitWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerUid)) {
            query["OwnerUid"] = request.ownerUid;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.parentUnitId)) {
            query["ParentUnitId"] = request.parentUnitId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCostUnit",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryCostUnitResponse({}));
    }
    async queryCostUnit(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryCostUnitWithOptions(request, runtime);
    }
    async queryCostUnitResourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerUid)) {
            query["OwnerUid"] = request.ownerUid;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.unitId)) {
            query["UnitId"] = request.unitId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCostUnitResource",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryCostUnitResourceResponse({}));
    }
    async queryCostUnitResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryCostUnitResourceWithOptions(request, runtime);
    }
    async queryCustomerAddressListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCustomerAddressList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryCustomerAddressListResponse({}));
    }
    async queryCustomerAddressList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryCustomerAddressListWithOptions(request, runtime);
    }
    /**
      * The UID of the deducted instance.
      *
      * @param request QueryDPUtilizationDetailRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryDPUtilizationDetailResponse
     */
    async queryDPUtilizationDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.deductedInstanceId)) {
            query["DeductedInstanceId"] = request.deductedInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.includeShare)) {
            query["IncludeShare"] = request.includeShare;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.instanceSpec)) {
            query["InstanceSpec"] = request.instanceSpec;
        }
        if (!tea_util_1.default.isUnset(request.lastToken)) {
            query["LastToken"] = request.lastToken;
        }
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["Limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.prodCode)) {
            query["ProdCode"] = request.prodCode;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDPUtilizationDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryDPUtilizationDetailResponse({}));
    }
    /**
      * The UID of the deducted instance.
      *
      * @param request QueryDPUtilizationDetailRequest
      * @return QueryDPUtilizationDetailResponse
     */
    async queryDPUtilizationDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryDPUtilizationDetailWithOptions(request, runtime);
    }
    async queryEvaluateListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billCycle)) {
            query["BillCycle"] = request.billCycle;
        }
        if (!tea_util_1.default.isUnset(request.bizTypeList)) {
            query["BizTypeList"] = request.bizTypeList;
        }
        if (!tea_util_1.default.isUnset(request.endAmount)) {
            query["EndAmount"] = request.endAmount;
        }
        if (!tea_util_1.default.isUnset(request.endBizTime)) {
            query["EndBizTime"] = request.endBizTime;
        }
        if (!tea_util_1.default.isUnset(request.endSearchTime)) {
            query["EndSearchTime"] = request.endSearchTime;
        }
        if (!tea_util_1.default.isUnset(request.outBizId)) {
            query["OutBizId"] = request.outBizId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.sortType)) {
            query["SortType"] = request.sortType;
        }
        if (!tea_util_1.default.isUnset(request.startAmount)) {
            query["StartAmount"] = request.startAmount;
        }
        if (!tea_util_1.default.isUnset(request.startBizTime)) {
            query["StartBizTime"] = request.startBizTime;
        }
        if (!tea_util_1.default.isUnset(request.startSearchTime)) {
            query["StartSearchTime"] = request.startSearchTime;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryEvaluateList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryEvaluateListResponse({}));
    }
    async queryEvaluateList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryEvaluateListWithOptions(request, runtime);
    }
    async queryFinancialAccountInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["UserId"] = request.userId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryFinancialAccountInfo",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryFinancialAccountInfoResponse({}));
    }
    async queryFinancialAccountInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryFinancialAccountInfoWithOptions(request, runtime);
    }
    /**
      * ##
      * *   This API operation has been upgraded to DescribeInstanceBill. We recommend that you call the [DescribeInstanceBill](~~209402~~) operation to query the bills of instances or billable items in a billing cycle. You can call the QueryInstanceBill operation to query a maximum of 50,000 data rows in a bill.
      * *   Instance bills are generated after bills are split. In most cases, the instance bills do not include data generated on the last day of the specified period.
      * *   The instance information changes within a billing cycle. The instance configurations and specifications and the time when the instance was used in the billing cycle are all recorded. For more information, see the corresponding bill details.
      * *   You can query the data generated in June 2020 or later for Cloud Communications services, and the data generated in November 2020 or later for Alibaba Cloud Domains.
      *
      * @param request QueryInstanceBillRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryInstanceBillResponse
     */
    async queryInstanceBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.billingDate)) {
            query["BillingDate"] = request.billingDate;
        }
        if (!tea_util_1.default.isUnset(request.granularity)) {
            query["Granularity"] = request.granularity;
        }
        if (!tea_util_1.default.isUnset(request.isBillingItem)) {
            query["IsBillingItem"] = request.isBillingItem;
        }
        if (!tea_util_1.default.isUnset(request.isHideZeroCharge)) {
            query["IsHideZeroCharge"] = request.isHideZeroCharge;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryInstanceBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryInstanceBillResponse({}));
    }
    /**
      * ##
      * *   This API operation has been upgraded to DescribeInstanceBill. We recommend that you call the [DescribeInstanceBill](~~209402~~) operation to query the bills of instances or billable items in a billing cycle. You can call the QueryInstanceBill operation to query a maximum of 50,000 data rows in a bill.
      * *   Instance bills are generated after bills are split. In most cases, the instance bills do not include data generated on the last day of the specified period.
      * *   The instance information changes within a billing cycle. The instance configurations and specifications and the time when the instance was used in the billing cycle are all recorded. For more information, see the corresponding bill details.
      * *   You can query the data generated in June 2020 or later for Cloud Communications services, and the data generated in November 2020 or later for Alibaba Cloud Domains.
      *
      * @param request QueryInstanceBillRequest
      * @return QueryInstanceBillResponse
     */
    async queryInstanceBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryInstanceBillWithOptions(request, runtime);
    }
    async queryInstanceByTagWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryInstanceByTag",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryInstanceByTagResponse({}));
    }
    async queryInstanceByTag(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryInstanceByTagWithOptions(request, runtime);
    }
    async queryInstanceGaapCostWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryInstanceGaapCost",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryInstanceGaapCostResponse({}));
    }
    async queryInstanceGaapCost(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryInstanceGaapCostWithOptions(request, runtime);
    }
    async queryInvoicingCustomerListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryInvoicingCustomerList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryInvoicingCustomerListResponse({}));
    }
    async queryInvoicingCustomerList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryInvoicingCustomerListWithOptions(request, runtime);
    }
    async queryOrdersWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.createTimeEnd)) {
            query["CreateTimeEnd"] = request.createTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.createTimeStart)) {
            query["CreateTimeStart"] = request.createTimeStart;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.paymentStatus)) {
            query["PaymentStatus"] = request.paymentStatus;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryOrders",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryOrdersResponse({}));
    }
    async queryOrders(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryOrdersWithOptions(request, runtime);
    }
    async queryPermissionListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.relationId)) {
            query["RelationId"] = request.relationId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryPermissionList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryPermissionListResponse({}));
    }
    async queryPermissionList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryPermissionListWithOptions(request, runtime);
    }
    async queryPrepaidCardsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.effectiveOrNot)) {
            query["EffectiveOrNot"] = request.effectiveOrNot;
        }
        if (!tea_util_1.default.isUnset(request.expiryTimeEnd)) {
            query["ExpiryTimeEnd"] = request.expiryTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.expiryTimeStart)) {
            query["ExpiryTimeStart"] = request.expiryTimeStart;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryPrepaidCards",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryPrepaidCardsResponse({}));
    }
    async queryPrepaidCards(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryPrepaidCardsWithOptions(request, runtime);
    }
    /**
      * You can call this operation to query the billable items of a service. A billable item is the minimum unit used to calculate costs.
      *
      * @param request QueryPriceEntityListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryPriceEntityListResponse
     */
    async queryPriceEntityListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryPriceEntityList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryPriceEntityListResponse({}));
    }
    /**
      * You can call this operation to query the billable items of a service. A billable item is the minimum unit used to calculate costs.
      *
      * @param request QueryPriceEntityListRequest
      * @return QueryPriceEntityListResponse
     */
    async queryPriceEntityList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryPriceEntityListWithOptions(request, runtime);
    }
    async queryProductListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.queryTotalCount)) {
            query["QueryTotalCount"] = request.queryTotalCount;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryProductList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryProductListResponse({}));
    }
    async queryProductList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryProductListWithOptions(request, runtime);
    }
    async queryRIUtilizationDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deductedInstanceId)) {
            query["DeductedInstanceId"] = request.deductedInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceSpec)) {
            query["InstanceSpec"] = request.instanceSpec;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.RICommodityCode)) {
            query["RICommodityCode"] = request.RICommodityCode;
        }
        if (!tea_util_1.default.isUnset(request.RIInstanceId)) {
            query["RIInstanceId"] = request.RIInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRIUtilizationDetail",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryRIUtilizationDetailResponse({}));
    }
    async queryRIUtilizationDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryRIUtilizationDetailWithOptions(request, runtime);
    }
    async queryRedeemWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRedeem",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryRedeemResponse({}));
    }
    async queryRedeem(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryRedeemWithOptions(request, runtime);
    }
    async queryRelationListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.statusList)) {
            query["StatusList"] = request.statusList;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["UserId"] = request.userId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRelationList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryRelationListResponse({}));
    }
    async queryRelationList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryRelationListWithOptions(request, runtime);
    }
    async queryResellerAvailableQuotaWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.itemCodes)) {
            query["ItemCodes"] = request.itemCodes;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryResellerAvailableQuota",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryResellerAvailableQuotaResponse({}));
    }
    async queryResellerAvailableQuota(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryResellerAvailableQuotaWithOptions(request, runtime);
    }
    async queryResellerUserAlarmThresholdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.alarmType)) {
            query["AlarmType"] = request.alarmType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryResellerUserAlarmThreshold",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryResellerUserAlarmThresholdResponse({}));
    }
    async queryResellerUserAlarmThreshold(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryResellerUserAlarmThresholdWithOptions(request, runtime);
    }
    async queryResourcePackageInstancesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.expiryTimeEnd)) {
            query["ExpiryTimeEnd"] = request.expiryTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.expiryTimeStart)) {
            query["ExpiryTimeStart"] = request.expiryTimeStart;
        }
        if (!tea_util_1.default.isUnset(request.includePartner)) {
            query["IncludePartner"] = request.includePartner;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryResourcePackageInstances",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryResourcePackageInstancesResponse({}));
    }
    async queryResourcePackageInstances(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryResourcePackageInstancesWithOptions(request, runtime);
    }
    async querySavingsPlansDeductLogWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.instanceType)) {
            query["InstanceType"] = request.instanceType;
        }
        if (!tea_util_1.default.isUnset(request.locale)) {
            query["Locale"] = request.locale;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySavingsPlansDeductLog",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySavingsPlansDeductLogResponse({}));
    }
    async querySavingsPlansDeductLog(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySavingsPlansDeductLogWithOptions(request, runtime);
    }
    async querySavingsPlansDiscountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySavingsPlansDiscount",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySavingsPlansDiscountResponse({}));
    }
    async querySavingsPlansDiscount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySavingsPlansDiscountWithOptions(request, runtime);
    }
    async querySavingsPlansInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.locale)) {
            query["Locale"] = request.locale;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySavingsPlansInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySavingsPlansInstanceResponse({}));
    }
    async querySavingsPlansInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySavingsPlansInstanceWithOptions(request, runtime);
    }
    async querySettleBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.isDisplayLocalCurrency)) {
            query["IsDisplayLocalCurrency"] = request.isDisplayLocalCurrency;
        }
        if (!tea_util_1.default.isUnset(request.isHideZeroCharge)) {
            query["IsHideZeroCharge"] = request.isHideZeroCharge;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.recordID)) {
            query["RecordID"] = request.recordID;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySettleBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySettleBillResponse({}));
    }
    async querySettleBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySettleBillWithOptions(request, runtime);
    }
    async querySkuPriceListWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new QuerySkuPriceListShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.priceFactorConditionMap)) {
            request.priceFactorConditionMapShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.priceFactorConditionMap, "PriceFactorConditionMap", "json");
        }
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySkuPriceList",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySkuPriceListResponse({}));
    }
    async querySkuPriceList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySkuPriceListWithOptions(request, runtime);
    }
    /**
      * *   This API operation has been upgraded to DescribeSplitItemBill. We recommend that you call the [DescribeSplitItemBill](~~208169~~) operation to query split bills. You can call the QuerySplitItemBill operation to query a maximum of 50,000 data rows in a bill.
      * *   The data queried by calling the QuerySplitItemBill operation is consistent with the data that is displayed for the specified billing cycle on the Split Bill page in User Center.
      * *   You can call this operation to query split bills generated within the last 12 months.
      * *   This operation returns split bills only after you activate the [Split Bill](https://usercenter2.aliyun.com/finance/split-bill) service in User Center.
      *
      * @param request QuerySplitItemBillRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QuerySplitItemBillResponse
     */
    async querySplitItemBillWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.billOwnerId)) {
            query["BillOwnerId"] = request.billOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.billingCycle)) {
            query["BillingCycle"] = request.billingCycle;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySplitItemBill",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QuerySplitItemBillResponse({}));
    }
    /**
      * *   This API operation has been upgraded to DescribeSplitItemBill. We recommend that you call the [DescribeSplitItemBill](~~208169~~) operation to query split bills. You can call the QuerySplitItemBill operation to query a maximum of 50,000 data rows in a bill.
      * *   The data queried by calling the QuerySplitItemBill operation is consistent with the data that is displayed for the specified billing cycle on the Split Bill page in User Center.
      * *   You can call this operation to query split bills generated within the last 12 months.
      * *   This operation returns split bills only after you activate the [Split Bill](https://usercenter2.aliyun.com/finance/split-bill) service in User Center.
      *
      * @param request QuerySplitItemBillRequest
      * @return QuerySplitItemBillResponse
     */
    async querySplitItemBill(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.querySplitItemBillWithOptions(request, runtime);
    }
    /**
      * You can call this operation to query the usage data of an Alibaba Cloud service. Take note of the following items:
      * *   The service code that you specify for querying the usage data of a specific Alibaba Cloud service must be valid. You can query the usage data by hour or by day.
      * *   The time that you specify must follow the ISO8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
      *     *   Latency exists in data pushes. Therefore, if you set the DataType parameter to Hour, the integrity of usage data recorded in the last 24 hours can be ensured. If you set the DataType parameter to Day, the integrity of usage data recorded in the last two days can be ensured.
      *     *   You can query the usage data that is recorded in the last quarter.
      *
      * @param request QueryUserOmsDataRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryUserOmsDataResponse
     */
    async queryUserOmsDataWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dataType)) {
            query["DataType"] = request.dataType;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.marker)) {
            query["Marker"] = request.marker;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.table)) {
            query["Table"] = request.table;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUserOmsData",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryUserOmsDataResponse({}));
    }
    /**
      * You can call this operation to query the usage data of an Alibaba Cloud service. Take note of the following items:
      * *   The service code that you specify for querying the usage data of a specific Alibaba Cloud service must be valid. You can query the usage data by hour or by day.
      * *   The time that you specify must follow the ISO8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
      *     *   Latency exists in data pushes. Therefore, if you set the DataType parameter to Hour, the integrity of usage data recorded in the last 24 hours can be ensured. If you set the DataType parameter to Day, the integrity of usage data recorded in the last two days can be ensured.
      *     *   You can query the usage data that is recorded in the last quarter.
      *
      * @param request QueryUserOmsDataRequest
      * @return QueryUserOmsDataResponse
     */
    async queryUserOmsData(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryUserOmsDataWithOptions(request, runtime);
    }
    /**
      * 1.  Refunds are applicable only for the actual paid amount. Vouchers used for the purchase are non-refundable.
      * 2.  Check the information about unsubscription and confirm the unsubscription terms and refundable amount. The resource that is unsubscribed cannot be restored.
      * 3.  For more information, see [Rules for unsubscribing from resources](https://help.aliyun.com/knowledge_detail/116043.html?spm=a2c81.e1d666e.app.2.62ae11271Kd6iM).
      *
      * @param request RefundInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RefundInstanceResponse
     */
    async refundInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.immediatelyRelease)) {
            query["ImmediatelyRelease"] = request.immediatelyRelease;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RefundInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RefundInstanceResponse({}));
    }
    /**
      * 1.  Refunds are applicable only for the actual paid amount. Vouchers used for the purchase are non-refundable.
      * 2.  Check the information about unsubscription and confirm the unsubscription terms and refundable amount. The resource that is unsubscribed cannot be restored.
      * 3.  For more information, see [Rules for unsubscribing from resources](https://help.aliyun.com/knowledge_detail/116043.html?spm=a2c81.e1d666e.app.2.62ae11271Kd6iM).
      *
      * @param request RefundInstanceRequest
      * @return RefundInstanceResponse
     */
    async refundInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.refundInstanceWithOptions(request, runtime);
    }
    /**
      * A value of true indicates that the execution is complete.
      * A value of false indicates that an error occurs during the execution.
      *
      * @param request ReleaseInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReleaseInstanceResponse
     */
    async releaseInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceIds)) {
            query["InstanceIds"] = request.instanceIds;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.renewStatus)) {
            query["RenewStatus"] = request.renewStatus;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReleaseInstanceResponse({}));
    }
    /**
      * A value of true indicates that the execution is complete.
      * A value of false indicates that an error occurs during the execution.
      *
      * @param request ReleaseInstanceRequest
      * @return ReleaseInstanceResponse
     */
    async releaseInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.releaseInstanceWithOptions(request, runtime);
    }
    async relieveAccountRelationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.childUserId)) {
            query["ChildUserId"] = request.childUserId;
        }
        if (!tea_util_1.default.isUnset(request.parentUserId)) {
            query["ParentUserId"] = request.parentUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationId)) {
            query["RelationId"] = request.relationId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["RelationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            query["RequestId"] = request.requestId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RelieveAccountRelation",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RelieveAccountRelationResponse({}));
    }
    async relieveAccountRelation(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.relieveAccountRelationWithOptions(request, runtime);
    }
    async renewInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.renewPeriod)) {
            query["RenewPeriod"] = request.renewPeriod;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RenewInstance",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RenewInstanceResponse({}));
    }
    async renewInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.renewInstanceWithOptions(request, runtime);
    }
    async renewResourcePackageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.duration)) {
            query["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.effectiveDate)) {
            query["EffectiveDate"] = request.effectiveDate;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pricingCycle)) {
            query["PricingCycle"] = request.pricingCycle;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RenewResourcePackage",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RenewResourcePackageResponse({}));
    }
    async renewResourcePackage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.renewResourcePackageWithOptions(request, runtime);
    }
    async saveUserCreditWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.avoidExpiration)) {
            query["AvoidExpiration"] = request.avoidExpiration;
        }
        if (!tea_util_1.default.isUnset(request.avoidNotification)) {
            query["AvoidNotification"] = request.avoidNotification;
        }
        if (!tea_util_1.default.isUnset(request.avoidPrepaidExpiration)) {
            query["AvoidPrepaidExpiration"] = request.avoidPrepaidExpiration;
        }
        if (!tea_util_1.default.isUnset(request.avoidPrepaidNotification)) {
            query["AvoidPrepaidNotification"] = request.avoidPrepaidNotification;
        }
        if (!tea_util_1.default.isUnset(request.creditType)) {
            query["CreditType"] = request.creditType;
        }
        if (!tea_util_1.default.isUnset(request.creditValue)) {
            query["CreditValue"] = request.creditValue;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.operator)) {
            query["Operator"] = request.operator;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SaveUserCredit",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SaveUserCreditResponse({}));
    }
    async saveUserCredit(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.saveUserCreditWithOptions(request, runtime);
    }
    async setAllExpirationDayWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.unifyExpireDay)) {
            query["UnifyExpireDay"] = request.unifyExpireDay;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetAllExpirationDay",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetAllExpirationDayResponse({}));
    }
    async setAllExpirationDay(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setAllExpirationDayWithOptions(request, runtime);
    }
    async setCreditLabelActionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.actionType)) {
            query["ActionType"] = request.actionType;
        }
        if (!tea_util_1.default.isUnset(request.clearCycle)) {
            query["ClearCycle"] = request.clearCycle;
        }
        if (!tea_util_1.default.isUnset(request.creditAmount)) {
            query["CreditAmount"] = request.creditAmount;
        }
        if (!tea_util_1.default.isUnset(request.currencyCode)) {
            query["CurrencyCode"] = request.currencyCode;
        }
        if (!tea_util_1.default.isUnset(request.dailyCycle)) {
            query["DailyCycle"] = request.dailyCycle;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.isNeedAddSettleLabel)) {
            query["IsNeedAddSettleLabel"] = request.isNeedAddSettleLabel;
        }
        if (!tea_util_1.default.isUnset(request.isNeedAdjustCreditAccount)) {
            query["IsNeedAdjustCreditAccount"] = request.isNeedAdjustCreditAccount;
        }
        if (!tea_util_1.default.isUnset(request.isNeedSaveNotifyRule)) {
            query["IsNeedSaveNotifyRule"] = request.isNeedSaveNotifyRule;
        }
        if (!tea_util_1.default.isUnset(request.isNeedSetCreditAmount)) {
            query["IsNeedSetCreditAmount"] = request.isNeedSetCreditAmount;
        }
        if (!tea_util_1.default.isUnset(request.needNotice)) {
            query["NeedNotice"] = request.needNotice;
        }
        if (!tea_util_1.default.isUnset(request.newCreateMode)) {
            query["NewCreateMode"] = request.newCreateMode;
        }
        if (!tea_util_1.default.isUnset(request.operator)) {
            query["Operator"] = request.operator;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            query["RequestId"] = request.requestId;
        }
        if (!tea_util_1.default.isUnset(request.siteCode)) {
            query["SiteCode"] = request.siteCode;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            query["Source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.uid)) {
            query["Uid"] = request.uid;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetCreditLabelAction",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetCreditLabelActionResponse({}));
    }
    async setCreditLabelAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setCreditLabelActionWithOptions(request, runtime);
    }
    async setRenewalWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceIDs)) {
            query["InstanceIDs"] = request.instanceIDs;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.productCode)) {
            query["ProductCode"] = request.productCode;
        }
        if (!tea_util_1.default.isUnset(request.productType)) {
            query["ProductType"] = request.productType;
        }
        if (!tea_util_1.default.isUnset(request.renewalPeriod)) {
            query["RenewalPeriod"] = request.renewalPeriod;
        }
        if (!tea_util_1.default.isUnset(request.renewalPeriodUnit)) {
            query["RenewalPeriodUnit"] = request.renewalPeriodUnit;
        }
        if (!tea_util_1.default.isUnset(request.renewalStatus)) {
            query["RenewalStatus"] = request.renewalStatus;
        }
        if (!tea_util_1.default.isUnset(request.subscriptionType)) {
            query["SubscriptionType"] = request.subscriptionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetRenewal",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetRenewalResponse({}));
    }
    async setRenewal(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setRenewalWithOptions(request, runtime);
    }
    async setResellerUserAlarmThresholdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.alarmThresholds)) {
            query["AlarmThresholds"] = request.alarmThresholds;
        }
        if (!tea_util_1.default.isUnset(request.alarmType)) {
            query["AlarmType"] = request.alarmType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetResellerUserAlarmThreshold",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetResellerUserAlarmThresholdResponse({}));
    }
    async setResellerUserAlarmThreshold(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setResellerUserAlarmThresholdWithOptions(request, runtime);
    }
    async setResellerUserQuotaWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.amount)) {
            query["Amount"] = request.amount;
        }
        if (!tea_util_1.default.isUnset(request.currency)) {
            query["Currency"] = request.currency;
        }
        if (!tea_util_1.default.isUnset(request.outBizId)) {
            query["OutBizId"] = request.outBizId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetResellerUserQuota",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetResellerUserQuotaResponse({}));
    }
    async setResellerUserQuota(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setResellerUserQuotaWithOptions(request, runtime);
    }
    async setResellerUserStatusWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.businessType)) {
            query["BusinessType"] = request.businessType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.stopMode)) {
            query["StopMode"] = request.stopMode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SetResellerUserStatus",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SetResellerUserStatusResponse({}));
    }
    async setResellerUserStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.setResellerUserStatusWithOptions(request, runtime);
    }
    async subscribeBillToOSSWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.beginBillingCycle)) {
            query["BeginBillingCycle"] = request.beginBillingCycle;
        }
        if (!tea_util_1.default.isUnset(request.bucketOwnerId)) {
            query["BucketOwnerId"] = request.bucketOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.bucketPath)) {
            query["BucketPath"] = request.bucketPath;
        }
        if (!tea_util_1.default.isUnset(request.multAccountRelSubscribe)) {
            query["MultAccountRelSubscribe"] = request.multAccountRelSubscribe;
        }
        if (!tea_util_1.default.isUnset(request.rowLimitPerFile)) {
            query["RowLimitPerFile"] = request.rowLimitPerFile;
        }
        if (!tea_util_1.default.isUnset(request.subscribeBucket)) {
            query["SubscribeBucket"] = request.subscribeBucket;
        }
        if (!tea_util_1.default.isUnset(request.subscribeType)) {
            query["SubscribeType"] = request.subscribeType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SubscribeBillToOSS",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SubscribeBillToOSSResponse({}));
    }
    async subscribeBillToOSS(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.subscribeBillToOSSWithOptions(request, runtime);
    }
    async tagResourcesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TagResources",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
    }
    async tagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.tagResourcesWithOptions(request, runtime);
    }
    async unsubscribeBillToOSSWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.multAccountRelSubscribe)) {
            query["MultAccountRelSubscribe"] = request.multAccountRelSubscribe;
        }
        if (!tea_util_1.default.isUnset(request.subscribeType)) {
            query["SubscribeType"] = request.subscribeType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnsubscribeBillToOSS",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnsubscribeBillToOSSResponse({}));
    }
    async unsubscribeBillToOSS(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unsubscribeBillToOSSWithOptions(request, runtime);
    }
    async untagResourcesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.all)) {
            query["All"] = request.all;
        }
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tagKey)) {
            query["TagKey"] = request.tagKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UntagResources",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
    }
    async untagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.untagResourcesWithOptions(request, runtime);
    }
    async upgradeResourcePackageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.effectiveDate)) {
            query["EffectiveDate"] = request.effectiveDate;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.specification)) {
            query["Specification"] = request.specification;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeResourcePackage",
            version: "2017-12-14",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeResourcePackageResponse({}));
    }
    async upgradeResourcePackage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.upgradeResourcePackageWithOptions(request, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map